<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mission Control - MoltBot</title>
    <style>
        :root {
            --bg-primary: #0d0d0d;
            --bg-secondary: #1a1a1a;
            --bg-card: #262626;
            --bg-modal: #1f1f1f;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent-blue: #3b82f6;
            --accent-green: #10b981;
            --accent-yellow: #f59e0b;
            --accent-red: #ef4444;
            --accent-purple: #8b5cf6;
            --border: #333333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .logo {
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-tabs {
            display: flex;
            gap: 0.5rem;
        }

        .nav-tab {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .nav-tab.active {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-github {
            background: #24292e;
            color: white;
        }

        .btn-github:hover {
            background: #1b1f23;
        }

        .btn-danger {
            background: var(--accent-red);
            color: white;
        }

        .btn-small {
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
        }

        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .live-indicator::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .live-indicator.live {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .live-indicator.stale {
            background: rgba(245, 158, 11, 0.2);
            color: var(--accent-yellow);
        }

        /* User Profile */
        .user-profile {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.375rem 0.75rem;
            background: var(--bg-card);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .user-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
        }

        .user-name {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .user-logout {
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .user-logout:hover {
            color: var(--accent-red);
            background: rgba(239, 68, 68, 0.1);
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 2rem;
            padding: 1rem 2rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }

        .stat {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .stat-highlight {
            color: var(--accent-green);
        }

        /* Unsaved Changes Banner */
        .unsaved-banner {
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 2rem;
            background: var(--accent-yellow);
            color: #000;
        }

        .unsaved-banner.visible {
            display: flex;
        }

        .unsaved-text {
            font-weight: 500;
        }

        /* Version Update Banner */
        .version-banner {
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 2rem;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            color: white;
            animation: versionPulse 2s ease-in-out infinite;
        }

        @keyframes versionPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }

        .version-banner.visible {
            display: flex;
        }

        .version-banner-text {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
        }

        .version-banner-text .update-icon {
            font-size: 1.1rem;
        }

        .version-banner .btn-refresh {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.375rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .version-banner .btn-refresh:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.02);
        }

        .version-banner .btn-dismiss {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            padding: 0.25rem;
            margin-left: 0.5rem;
            font-size: 1.1rem;
            line-height: 1;
            transition: color 0.2s;
        }

        .version-banner .btn-dismiss:hover {
            color: white;
        }

        /* Filters */
        .filters {
            display: flex;
            gap: 0.5rem;
            padding: 1rem 2rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 0.375rem 0.75rem;
            border-radius: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            border-color: var(--accent-blue);
        }

        .filter-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        /* Main Layout */
        .main {
            display: flex;
            height: calc(100vh - 180px);
        }

        /* Kanban Board */
        .kanban {
            flex: 1;
            display: flex;
            gap: 1rem;
            padding: 1rem 2rem;
            overflow-x: auto;
            align-items: stretch;
        }

        .column {
            min-width: 300px;
            max-width: 350px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        .column-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .column-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .column-dot.recurring { background: #06b6d4; } /* Cyan/Teal for recurring */
        .column-dot.permanent { background: var(--accent-purple); }
        .column-dot.scheduled { background: #f97316; } /* Orange for scheduled */
        .column-dot.templates { background: #8B5CF6; } /* Purple for templates */
        .column-dot.backlog { background: var(--accent-yellow); }
        .column-dot.in-progress { background: var(--accent-blue); }
        .column-dot.review { background: var(--accent-green); }
        .column-dot.done { background: #6b7280; }

        .column-title {
            font-weight: 500;
        }

        .column-count {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .column-add {
            margin-left: auto;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.25rem;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .column-add:hover {
            background: var(--bg-card);
            color: var(--accent-blue);
        }

        .column-add.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .archive-all-btn {
            margin-left: auto;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .archive-all-btn:hover {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }

        .task-card.archived {
            opacity: 0.6;
            border-left: 3px solid var(--accent-purple);
        }

        .task-card.archived .task-title::before {
            content: 'ðŸ“¦ ';
        }

        .archived-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent-purple);
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 500;
        }

        .column-tasks {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            flex: 1;
            padding-bottom: 1rem;
            align-items: stretch; /* Cards take full width but not full height */
        }

        /* Task Card */
        .task-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            border: 1px solid transparent;
            /* No automatic animation - FLIP handles movement */
            transition: opacity 0.3s, filter 0.3s;
            /* Prevent stretching */
            display: block;
            height: auto;
        }
        
        .task-card.search-dimmed {
            opacity: 0.25;
            filter: grayscale(0.5);
            pointer-events: none;
        }

        /* Cron Cards */
        .cron-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 0.875rem;
            border-left: 3px solid #06b6d4;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        
        .cron-card:hover {
            transform: translateY(-2px);
            border-color: #22d3ee;
        }
        
        .cron-card[draggable="true"] {
            cursor: grab;
        }
        
        .cron-card.dragging {
            opacity: 0.4;
            cursor: grabbing;
        }
        
        /* Template Cards */
        .template-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 0.875rem;
            border-left: 3px solid #8B5CF6;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        
        .template-card:hover {
            transform: translateY(-2px);
            border-color: #a78bfa;
        }
        
        .template-card .template-name {
            font-weight: 500;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        
        .template-card .template-description {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .template-card .template-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .template-card .execution-count {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
        }
        
        .template-card .template-actions {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }
        
        .template-card .template-action-btn {
            flex: 1;
            padding: 0.25rem 0.5rem;
            border: none;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
        }
        
        .template-card .template-action-btn:hover {
            background: rgba(139, 92, 246, 0.3);
        }
        
        .template-card .template-action-btn.run {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-green);
        }
        
        .template-card .template-action-btn.run:hover {
            background: rgba(16, 185, 129, 0.3);
        }
        
        /* Scheduled Task Cards */
        .scheduled-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 0.875rem;
            border-left: 3px solid #f97316;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        
        .scheduled-card:hover {
            transform: translateY(-2px);
            border-color: #fb923c;
        }
        
        .scheduled-card .scheduled-name {
            font-weight: 500;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        
        .scheduled-card .scheduled-time {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }
        
        .scheduled-card .countdown {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: rgba(249, 115, 22, 0.15);
            color: #fb923c;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
        }
        
        .scheduled-card .countdown.overdue {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-red);
            animation: pulse 1s infinite;
        }
        
        .cron-card .cron-name {
            font-weight: 500;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        
        .cron-card .cron-schedule {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }
        
        .cron-card .cron-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
        }
        
        .cron-card .cron-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .cron-card .cron-status-dot.ok { background: var(--accent-green); }
        .cron-card .cron-status-dot.error { background: var(--accent-red); }
        .cron-card .cron-status-dot.disabled { background: var(--text-secondary); }
        .cron-card .cron-status-dot.pending { background: var(--accent-yellow, #f59e0b); animation: pulse 2s infinite; }
        .cron-card .cron-status-dot.running { 
            background: var(--accent-blue);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        .cron-card .cron-next {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }
        
        /* Search Input */
        .search-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .search-input-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .search-input {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 2rem 0.5rem 2.25rem;
            color: var(--text-primary);
            font-size: 0.875rem;
            width: 200px;
            transition: all 0.2s;
        }
        
        .search-input:focus,
        .search-input.expanded {
            outline: none;
            border-color: var(--accent-blue);
            width: 280px;
        }
        
        .search-input::placeholder {
            color: var(--text-secondary);
        }
        
        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            pointer-events: none;
        }
        
        .search-clear {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            display: none;
            font-size: 1rem;
            line-height: 1;
        }
        
        .search-clear:hover {
            color: var(--text-primary);
        }
        
        .search-input:not(:placeholder-shown) ~ .search-clear {
            display: block;
        }
        
        .search-info {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .archive-search-toggle {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.7rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
            user-select: none;
        }

        .archive-search-toggle:hover {
            background: var(--bg-card);
        }

        .archive-search-toggle input {
            cursor: pointer;
        }

        .archive-search-toggle input:checked + span {
            color: var(--accent-purple);
        }

        .task-card.priority-changed {
            animation: priorityPulse 0.5s ease-out;
        }

        /* Old dragging styles moved to Drag & Drop section below */

        @keyframes priorityPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); box-shadow: 0 0 20px rgba(99, 102, 241, 0.4); }
            100% { transform: scale(1); }
        }

        .task-card:hover {
            border-color: var(--border);
            transform: translateY(-2px);
        }

        .task-card.priority-high {
            border-left: 3px solid var(--accent-red);
        }

        .task-card.priority-medium {
            border-left: 3px solid var(--accent-yellow);
        }

        .task-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }

        .task-title-text {
            flex: 1;
        }

        .task-description {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 0.75rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            max-height: 2.8em; /* Fallback: ~2 lines at 0.875rem */
            line-height: 1.4;
            white-space: pre-line; /* Respect newlines but wrap */
        }

        .task-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
        }

        .task-comment-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            color: var(--text-muted);
            font-size: 0.75rem;
            flex-shrink: 0;
        }

        .task-comment-indicator svg {
            opacity: 0.7;
        }
        
        /* Processing indicator (agent working on task) */
        .task-processing {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            margin: 8px 0;
            background: linear-gradient(90deg, rgba(99, 102, 241, 0.15), rgba(59, 130, 246, 0.15));
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--accent-blue);
            animation: processingPulse 2s ease-in-out infinite;
        }
        
        /* Pulsing border effect on processing task cards */
        .task-card.processing-active {
            border-color: var(--accent-blue) !important;
            box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            animation: processingBorderPulse 2s ease-in-out infinite;
        }
        
        @keyframes processingBorderPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            }
            50% { 
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0);
            }
        }
        
        /* Timeout warning (30+ minutes) */
        .task-processing.timeout-warning {
            background: linear-gradient(90deg, rgba(245, 158, 11, 0.2), rgba(239, 68, 68, 0.15));
            color: var(--accent-yellow);
        }
        
        .task-card.processing-timeout {
            border-color: var(--accent-red) !important;
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            animation: timeoutBorderPulse 2s ease-in-out infinite;
        }
        
        @keyframes timeoutBorderPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.3);
            }
            50% { 
                box-shadow: 0 0 0 6px rgba(239, 68, 68, 0);
            }
        }
        
        .processing-time {
            font-size: 0.7rem;
            opacity: 0.8;
        }
        
        @keyframes processingPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .processing-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .task-tags {
            display: flex;
            gap: 0.375rem;
            flex-wrap: wrap;
        }

        .task-tag {
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            background: var(--bg-secondary);
            /* Prevent other class rules from affecting tag size */
            min-height: auto !important;
            height: auto !important;
            display: inline-block;
        }

        .task-tag.linkedin { background: #0077b520; color: #0077b5; }
        .task-tag.project-a { background: #10b98120; color: #10b981; }
        .task-tag.project-b { background: #8b5cf620; color: #8b5cf6; }
        .task-tag.system { background: #6b728020; color: #9ca3af; }

        .tag-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            font-size: 0.8rem;
        }
        .tag-chip .tag-remove {
            cursor: pointer;
            opacity: 0.6;
            font-size: 0.9rem;
        }
        .tag-chip .tag-remove:hover {
            opacity: 1;
            color: #ef4444;
        }

        .btn-icon {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .btn-icon:hover {
            background: var(--bg-secondary);
        }

        .project-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 8px;
        }
        .project-item .project-icon {
            font-size: 1.2rem;
        }
        .project-item .project-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        .project-item .project-name {
            flex: 1;
            font-weight: 500;
        }
        .project-item .project-id {
            color: var(--text-secondary);
            font-size: 0.8rem;
        }
        .project-item .project-actions {
            display: flex;
            gap: 4px;
        }
        .project-item .project-actions button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            opacity: 0.6;
        }
        .project-item .project-actions button:hover {
            opacity: 1;
            background: var(--bg-primary);
        }

        .emoji-btn {
            width: 36px;
            height: 36px;
            font-size: 1.2rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .emoji-btn:hover {
            background: var(--bg-primary);
            transform: scale(1.1);
        }
        .emoji-btn.selected {
            border-color: var(--accent);
            background: var(--accent);
        }

        .view {
            display: none;
        }
        .view.active {
            display: block;
        }

        .docs-container h2 {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        .docs-container code {
            background: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }
        .docs-container details {
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
        }
        .docs-container details summary {
            outline: none;
        }

        .task-date {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .task-subtasks {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .subtask-progress {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .progress-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-secondary);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-green);
            transition: width 0.3s;
        }

        /* Subtasks in Modal */
        .subtasks-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .subtask-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .subtask-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .subtask-item .subtask-title {
            flex: 1;
            font-size: 0.875rem;
        }

        .subtask-item .subtask-title.done {
            text-decoration: line-through;
            color: var(--text-secondary);
        }

        .subtask-item .subtask-delete {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .subtask-item:hover .subtask-delete {
            opacity: 1;
        }

        .subtask-item .subtask-delete:hover {
            color: var(--accent-red);
        }

        .subtask-add, .comment-add {
            display: flex;
            gap: 0.5rem;
            align-items: flex-start;
        }

        .subtask-add input, .comment-add textarea {
            flex: 1;
        }

        /* Comments in Modal */
        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .comment-item {
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        .comment-author {
            font-weight: 500;
            font-size: 0.875rem;
        }

        .comment-time {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .comment-text {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* Task Actions (Review buttons) */
        .task-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .task-action-btn {
            flex: 1;
            padding: 0.375rem 0.5rem;
            border: none;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .task-action-btn.done {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .task-action-btn.done:hover {
            background: rgba(16, 185, 129, 0.4);
        }

        .task-action-btn.backlog {
            background: rgba(245, 158, 11, 0.2);
            color: var(--accent-yellow);
        }

        .task-action-btn.backlog:hover {
            background: rgba(245, 158, 11, 0.4);
        }

        .task-action-btn.archive {
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent-purple);
        }

        .task-action-btn.archive:hover {
            background: rgba(139, 92, 246, 0.4);
        }

        .task-action-btn.unarchive {
            background: rgba(59, 130, 246, 0.2);
            color: var(--accent-blue);
        }

        .task-action-btn.unarchive:hover {
            background: rgba(59, 130, 246, 0.4);
        }

        /* Drag & Drop - Trello-style smooth animations */
        .task-card[draggable="true"] {
            cursor: grab;
            transition: transform 0.2s cubic-bezier(0.2, 0, 0.2, 1),
                        opacity 0.2s ease,
                        margin 0.2s cubic-bezier(0.2, 0, 0.2, 1);
        }

        .task-card.dragging {
            opacity: 0.4;
            cursor: grabbing;
            transform: scale(0.95) rotate(2deg);
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .column-tasks.drag-over {
            background: rgba(59, 130, 246, 0.05);
            border-radius: 8px;
        }

        /* Smooth gap opening for drop target */
        .task-card.make-space-above {
            margin-top: 60px;
        }

        .task-card.make-space-below {
            margin-bottom: 60px;
        }

        /* Visual drop indicator line */
        .drop-indicator {
            height: 3px;
            background: linear-gradient(90deg, var(--accent), var(--accent-blue));
            border-radius: 2px;
            margin: 2px 0;
            opacity: 0;
            transition: opacity 0.15s ease;
            pointer-events: none;
        }

        .drop-indicator.visible {
            opacity: 1;
        }

        /* Empty column drop zone */
        .column-tasks.drag-over:empty::after {
            content: 'Drop here';
            display: block;
            padding: 40px 20px;
            text-align: center;
            color: var(--accent-blue);
            font-size: 0.875rem;
            border: 2px dashed var(--accent-blue);
            border-radius: 8px;
            opacity: 0.7;
        }

        /* Prevent janky transitions during render */
        .column-tasks.no-transition .task-card {
            transition: none !important;
            animation: none !important;
        }

        /* Activity Feed */
        .activity {
            width: 320px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            padding: 1rem;
            overflow-y: auto;
            transition: all 0.3s ease;
            position: relative;
        }

        .activity.collapsed {
            width: 0;
            padding: 0;
            border-left: none;
            overflow: hidden;
        }

        .activity-toggle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.875rem;
            transition: all 0.2s;
            margin-left: auto;
        }

        .activity-toggle:hover {
            background: var(--border);
            color: var(--text-primary);
        }

        /* Reopen button when collapsed */
        .activity-reopen {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 32px;
            height: 80px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-right: none;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 0.75rem;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            z-index: 100;
        }

        .activity-reopen:hover {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .activity.collapsed ~ .activity-reopen,
        body:has(.activity.collapsed) .activity-reopen {
            display: flex;
        }

        .activity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .activity-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .activity-item {
            display: flex;
            gap: 0.75rem;
            font-size: 0.875rem;
        }

        .activity-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-top: 0.375rem;
            flex-shrink: 0;
        }

        .activity-dot.created { background: var(--accent-green); }
        .activity-dot.moved { background: var(--accent-blue); }
        .activity-dot.completed { background: var(--accent-purple); }
        .activity-dot.deleted { background: var(--accent-red); }
        .activity-dot.archive { background: var(--accent-purple); }
        .activity-dot.unarchive { background: var(--accent-blue); }

        .activity-content {
            flex: 1;
        }

        .activity-actor {
            font-weight: 500;
        }

        .activity-action {
            color: var(--text-secondary);
        }

        .activity-task {
            color: var(--accent-blue);
        }

        .activity-time {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }

        /* Empty State */
        .empty-state {
            color: var(--text-secondary);
            text-align: center;
            padding: 2rem;
            font-size: 0.875rem;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: var(--bg-modal);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid var(--border);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 1.25rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.875rem;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .form-hint {
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .form-hint a {
            color: var(--accent-blue);
        }

        /* Steps */
        .steps {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .step {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }

        .step-number {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--accent-blue);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .step-description {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* Validation States */
        .validation-loading {
            display: none;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .validation-loading.visible {
            display: flex;
        }

        .validation-success {
            display: none;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: var(--accent-green);
        }

        .validation-success.visible {
            display: flex;
        }

        .validation-error {
            display: none;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: var(--accent-red);
        }

        .validation-error.visible {
            display: flex;
        }

        /* Spinner */
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast */
        .toast-container {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .toast {
            padding: 1rem 1.5rem;
            border-radius: 8px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideIn 0.3s ease;
        }

        .toast.success {
            border-color: var(--accent-green);
        }

        .toast.error {
            border-color: var(--accent-red);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }

            .header-left {
                flex-direction: column;
                gap: 1rem;
                width: 100%;
            }

            .stats-bar {
                flex-wrap: wrap;
                gap: 1rem;
                padding: 1rem;
            }

            .main {
                flex-direction: column;
                height: auto;
            }

            .kanban {
                padding: 1rem;
                flex-direction: column;
            }

            .column {
                min-width: 100%;
                max-width: 100%;
            }

            .activity {
                width: 100%;
                border-left: none;
                border-top: 1px solid var(--border);
            }
        }

        /* === LOGIN SCREEN === */
        .login-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--bg-primary) 0%, #1a1a2e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .login-container {
            text-align: center;
            max-width: 480px;
            width: 90%;
        }

        .login-logo {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .login-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .login-subtitle {
            color: var(--text-secondary);
            margin-bottom: 2rem;
            font-size: 1.1rem;
        }

        .login-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 2rem;
            text-align: left;
        }

        .login-card h2 {
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            font-size: 1.3rem;
        }

        .login-card > p {
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .login-steps {
            margin-bottom: 1.5rem;
        }

        .login-step {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: flex-start;
        }

        .login-step-num {
            background: var(--accent);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .login-step strong {
            display: block;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .login-link {
            color: var(--accent);
            text-decoration: none;
            font-size: 0.9rem;
        }

        .login-link:hover {
            text-decoration: underline;
        }

        .login-hint {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .login-form {
            margin-top: 1.5rem;
        }

        .login-input {
            width: 100%;
            padding: 0.875rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
            margin-bottom: 1rem;
            box-sizing: border-box;
        }

        .login-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .login-btn {
            width: 100%;
            padding: 0.875rem 1.5rem;
            background: #238636;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transition: background 0.2s;
        }

        .login-btn:hover {
            background: #2ea043;
        }

        .login-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .login-error {
            display: none;
            color: var(--accent-red);
            margin-top: 1rem;
            padding: 0.75rem;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .login-loading {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
            color: var(--text-secondary);
        }

        .login-security {
            margin-top: 1.5rem;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        #dashboard {
            min-height: 100vh;
        }

        /* === PEOPLE / COLLABORATORS === */
        .people-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
        }

        .people-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .people-header h1 {
            font-size: 1.75rem;
            font-weight: 600;
        }

        .people-stats {
            display: flex;
            gap: 1rem;
        }

        .people-stat {
            background: var(--bg-card);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .people-stat strong {
            color: var(--text-primary);
        }

        .collaborators-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .collaborator-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 1.25rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all 0.2s;
            border: 1px solid var(--border);
        }

        .collaborator-card:hover {
            border-color: var(--accent-blue);
            transform: translateY(-2px);
        }

        .collaborator-avatar {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border);
        }

        .collaborator-info {
            flex: 1;
            min-width: 0;
        }

        .collaborator-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .collaborator-username {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }

        .collaborator-username a {
            color: var(--text-secondary);
            text-decoration: none;
        }

        .collaborator-username a:hover {
            color: var(--accent-blue);
        }

        .collaborator-role {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .role-admin {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
        }

        .role-maintain {
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
        }

        .role-write {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }

        .role-triage {
            background: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
        }

        .role-read {
            background: rgba(107, 114, 128, 0.15);
            color: #9ca3af;
        }

        .people-loading {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .people-loading .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        .people-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .people-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
<base target="_blank">
</head>
<body>
    <!-- Login Required Screen (shown when not authenticated) -->
    <div id="login-screen" class="login-screen">
        <div class="login-container">
            <div class="login-logo">ðŸŽ¯</div>
            <h1 class="login-title">Mission Control</h1>
            <p class="login-subtitle">Task & Project Management Dashboard</p>

            <div class="login-card">
                <h2>ðŸ” Login Required</h2>
                <p>Connect your GitHub account to access the dashboard.</p>

                <div class="login-steps">
                    <div class="login-step">
                        <span class="login-step-num">1</span>
                        <div>
                            <strong>Create a Personal Access Token</strong>
                            <a href="https://github.com/settings/tokens/new?scopes=repo&description=Mission%20Control%20Dashboard" target="_blank" class="login-link">
                                Create token on GitHub â†’
                            </a>
                        </div>
                    </div>
                    <div class="login-step">
                        <span class="login-step-num">2</span>
                        <div>
                            <strong>Select "repo" scope</strong>
                            <span class="login-hint">Allows read/write access to repositories</span>
                        </div>
                    </div>
                    <div class="login-step">
                        <span class="login-step-num">3</span>
                        <div>
                            <strong>Paste your token below</strong>
                            <span class="login-hint">Starts with "ghp_"</span>
                        </div>
                    </div>
                </div>

                <div class="login-form">
                    <input type="password" id="login-token-input" class="login-input" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" autocomplete="off">
                    <button id="login-btn" class="login-btn" onclick="handleLogin()">
                        <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor">
                            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                        </svg>
                        Connect with GitHub
                    </button>
                    <div id="login-error" class="login-error"></div>
                    <div id="login-loading" class="login-loading">
                        <div class="spinner"></div>
                        <span>Validating...</span>
                    </div>
                </div>

                <p class="login-security">ðŸ”’ Your token is stored locally and never sent anywhere except GitHub.</p>
            </div>
        </div>
    </div>

    <!-- Main Dashboard (hidden until authenticated) -->
    <div id="dashboard" class="dashboard" style="display: none;">

    <header class="header">
        <div class="header-left">
            <div class="logo">
                <span>ðŸŽ¯</span>
                <span>Mission Control</span>
            </div>
            <nav class="nav-tabs">
                <div class="nav-tab active" data-view="tasks" onclick="switchView('tasks')">Tasks</div>
                <div class="nav-tab" data-view="docs" onclick="switchView('docs')">Docs</div>
                <div class="nav-tab" data-view="people" onclick="switchView('people')">People</div>
            </nav>
            
            <!-- Search -->
            <div class="search-container">
                <div class="search-input-wrapper">
                    <input type="text" 
                           id="search-input" 
                           class="search-input" 
                           placeholder="Search tasks..." 
                           oninput="handleSearch(this.value)"
                           onkeydown="if(event.key==='Escape'){clearSearch()}">
                    <svg class="search-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="M21 21l-4.35-4.35"></path>
                    </svg>
                    <button class="search-clear" onmousedown="event.preventDefault()" onclick="clearSearch()" title="Clear search">Ã—</button>
                </div>
                <span class="search-info" id="search-info"></span>
                <label class="archive-search-toggle" title="Include archived tasks in search">
                    <input type="checkbox" id="search-include-archived" onchange="toggleArchiveSearch(this.checked)">
                    <span>ðŸ“¦ Archive</span>
                </label>
            </div>
        </div>
        <div class="header-right">
            <span class="live-indicator live" id="live-indicator">Live</span>
            <button class="btn btn-secondary" onclick="pollForUpdates(); window.location.reload()">â†» Refresh</button>

            <!-- Not Logged In -->
            <button class="btn btn-github" id="btn-connect" onclick="showAuthModal()">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                Connect GitHub
            </button>

            <!-- Logged In (hidden by default) -->
            <div class="user-profile" id="user-profile" style="display: none;">
                <img class="user-avatar" id="user-avatar" src="" alt="Avatar">
                <span class="user-name" id="user-name"></span>
                <button class="btn-icon" onclick="showSettingsModal()" title="Settings">âš™ï¸</button>
                <span class="user-logout" onclick="logout()">Logout</span>
            </div>
        </div>
    </header>

    <!-- Version Update Banner -->
    <div class="version-banner" id="version-banner">
        <div class="version-banner-text">
            <span class="update-icon">ðŸ”„</span>
            Neue Version verfÃ¼gbar!
        </div>
        <div>
            <button class="btn-refresh" onclick="reloadPage()">â†» Aktualisieren</button>
            <button class="btn-dismiss" onclick="dismissVersionBanner()">âœ•</button>
        </div>
    </div>

    <!-- Unsaved Changes Banner -->
    <div class="unsaved-banner" id="unsaved-banner">
        <span class="unsaved-text">âš ï¸ You have unsaved changes</span>
        <div>
            <button class="btn btn-secondary btn-small" onclick="discardChanges()">Discard</button>
            <button class="btn btn-primary btn-small" onclick="showCommitModal()">Save & Commit</button>
        </div>
    </div>

    <!-- TASKS VIEW -->
    <div id="view-tasks" class="view active">

    <div class="stats-bar">
        <div class="stat">
            <span class="stat-value" id="stat-week">0</span>
            <span class="stat-label">This week</span>
        </div>
        <div class="stat">
            <span class="stat-value" id="stat-progress">0</span>
            <span class="stat-label">In progress</span>
        </div>
        <div class="stat">
            <span class="stat-value" id="stat-total">0</span>
            <span class="stat-label">Total</span>
        </div>
        <div class="stat">
            <span class="stat-value stat-highlight" id="stat-completion">0%</span>
            <span class="stat-label">Completion</span>
        </div>
    </div>

    <div class="filters" id="filters">
        <button class="filter-btn active" data-filter="all">All projects</button>
    </div>

    <main class="main">
        <div class="kanban">
            <div class="column column-recurring">
                <div class="column-header">
                    <div class="column-dot recurring"></div>
                    <span class="column-title">Recurring</span>
                    <span class="column-count" id="count-recurring">0</span>
                </div>
                <div class="column-tasks" id="tasks-recurring" ondragover="handleCronDragOver(event)" ondragleave="handleCronDragLeave(event)" ondrop="handleCronDrop(event)"></div>
            </div>

            <div class="column column-scheduled">
                <div class="column-header">
                    <div class="column-dot scheduled"></div>
                    <span class="column-title">ðŸ“… Scheduled</span>
                    <span class="column-count" id="count-scheduled">0</span>
                    <span class="column-add" onclick="openScheduledTaskModal()" title="Schedule a task">+</span>
                </div>
                <div class="column-tasks" id="tasks-scheduled" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'scheduled')"></div>
            </div>

            <div class="column column-templates">
                <div class="column-header">
                    <div class="column-dot templates"></div>
                    <span class="column-title">ðŸ“‘ Templates</span>
                    <span class="column-count" id="count-templates">0</span>
                    <span class="column-add" onclick="openNewTemplate()" title="Add new template">+</span>
                </div>
                <div class="column-tasks" id="tasks-templates"></div>
            </div>

            <div class="column">
                <div class="column-header">
                    <div class="column-dot permanent"></div>
                    <span class="column-title">Permanent</span>
                    <span class="column-count" id="count-permanent">0</span>
                    <span class="column-add" onclick="openNewTask('permanent')" title="Add new task">+</span>
                </div>
                <div class="column-tasks" id="tasks-permanent" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'permanent')"></div>
            </div>

            <div class="column">
                <div class="column-header">
                    <div class="column-dot backlog"></div>
                    <span class="column-title">Backlog</span>
                    <span class="column-count" id="count-backlog">0</span>
                    <span class="column-add" onclick="openNewTask('backlog')" title="Add new task">+</span>
                </div>
                <div class="column-tasks" id="tasks-backlog" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'backlog')"></div>
            </div>

            <div class="column">
                <div class="column-header">
                    <div class="column-dot in-progress"></div>
                    <span class="column-title">In Progress</span>
                    <span class="column-count" id="count-in_progress">0</span>
                    <span class="column-add" onclick="openNewTask('in_progress')" title="Add new task">+</span>
                </div>
                <div class="column-tasks" id="tasks-in_progress" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'in_progress')"></div>
            </div>

            <div class="column">
                <div class="column-header">
                    <div class="column-dot review"></div>
                    <span class="column-title">Review</span>
                    <span class="column-count" id="count-review">0</span>
                    <span class="column-add" onclick="openNewTask('review')" title="Add new task">+</span>
                </div>
                <div class="column-tasks" id="tasks-review" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'review')"></div>
            </div>

            <div class="column">
                <div class="column-header">
                    <div class="column-dot done"></div>
                    <span class="column-title">Done</span>
                    <span class="column-count" id="count-done">0</span>
                    <button class="archive-all-btn" onclick="showArchiveView()" title="View archived tasks" style="background: transparent;">ðŸ“‚ View</button>
                    <button class="archive-all-btn" onclick="archiveAllDone()" title="Archive all done tasks">ðŸ“¦ Archive All</button>
                </div>
                <div class="column-tasks" id="tasks-done" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'done')"></div>
            </div>
        </div>

        <aside class="activity" id="activity-sidebar">
            <div class="activity-header">
                <span>ACTIVITY</span>
                <button class="activity-toggle" onclick="toggleActivity()" title="Hide Activity">
                    <span id="activity-toggle-icon">âœ•</span>
                </button>
            </div>
            <div class="activity-list" id="activity-list"></div>
        </aside>
        <button class="activity-reopen" id="activity-reopen" onclick="toggleActivity()" title="Show Activity">
            ACTIVITY
        </button>
    </main>

    </div><!-- END view-tasks -->

    <!-- DOCS VIEW -->
    <div id="view-docs" class="view" style="display: none;">
        <div class="docs-container" style="max-width: 900px; margin: 0 auto; padding: 2rem;">
            <h1 style="margin-bottom: 1.5rem;">ðŸ“š Mission Control Documentation</h1>

            <div class="docs-section" style="margin-bottom: 2rem; background: var(--bg-secondary); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--accent);">
                <h2 style="color: var(--accent); margin-bottom: 0.5rem;">ðŸ“Œ Demo Mode</h2>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    You're currently viewing <strong>sample data</strong>. To manage your own tasks, click <strong>"Connect GitHub"</strong> in the top right corner to link your repository.
                </p>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">ðŸš€ Getting Started</h2>

                <h3 style="margin: 1rem 0 0.5rem;">Installation</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Add Mission Control to your existing MoltBot workspace:
                </p>
                <ol style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li><strong>Fork</strong> this repository to your GitHub account</li>
                    <li><strong>Copy dashboard files</strong> to your workspace: <code>index.html</code>, <code>data/</code>, <code>canvas/</code>, <code>scripts/</code>, <code>.github/</code></li>
                    <li>Enable <strong>GitHub Pages</strong> in your repo settings (Settings â†’ Pages â†’ Branch: main)</li>
                    <li>Visit <code>https://[username].github.io/mission-control/</code></li>
                </ol>

                <h3 style="margin: 1.5rem 0 0.5rem;">Connect to GitHub</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Click <strong>"Connect GitHub"</strong> in the top right corner. You'll need a GitHub Personal Access Token with <code>repo</code> permissions.
                </p>
                <ol style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li>Go to <a href="https://github.com/settings/tokens" target="_blank" style="color: var(--accent);">GitHub Settings â†’ Tokens</a></li>
                    <li>Click "Generate new token (classic)"</li>
                    <li>Select scope: <code>repo</code> (Full control of private repositories)</li>
                    <li>Copy the token and paste it in Mission Control</li>
                </ol>

                <h3 style="margin: 1.5rem 0 0.5rem;">Understanding the Board</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Mission Control uses a Kanban-style board with 5 columns:
                </p>
                <ul style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li><strong>ðŸ”„ Permanent</strong> - Repeating tasks (daily, weekly checks)</li>
                    <li><strong>ðŸ“‹ Backlog</strong> - Tasks waiting to be started</li>
                    <li><strong>ðŸš€ In Progress</strong> - Currently being worked on</li>
                    <li><strong>ðŸ‘€ Review</strong> - Done, awaiting approval</li>
                    <li><strong>âœ… Done</strong> - Completed tasks</li>
                </ul>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">âœ¨ Features</h2>

                <h3 style="margin: 1rem 0 0.5rem;">Auto-Save</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    All changes are <strong>automatically saved</strong> to GitHub. No manual "Save" button needed!
                </p>
                <ul style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li>Drag & drop tasks between columns â†’ instant save</li>
                    <li>Edit task details â†’ instant save</li>
                    <li>Add/remove subtasks â†’ instant save</li>
                    <li>Add comments â†’ instant save</li>
                </ul>

                <h3 style="margin: 1.5rem 0 0.5rem;">Drag & Drop</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Click and drag any task card to move it between columns. The status updates automatically.
                </p>

                <h3 style="margin: 1.5rem 0 0.5rem;">Subtasks</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Break down tasks into smaller steps. Click on a subtask to edit it inline.
                </p>

                <h3 style="margin: 1.5rem 0 0.5rem;">Comments</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Add comments to tasks for context or feedback. Comments on <strong>Review</strong> tasks trigger notifications to MoltBot.
                </p>

                <h3 style="margin: 1.5rem 0 0.5rem;">Projects & Tags</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Organize tasks by project. Use the âš™ï¸ Settings to add new projects. Filter tasks using the project buttons.
                </p>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">ðŸ¤– MoltBot Integration</h2>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Mission Control is connected to MoltBot via webhooks. When you make changes:
                </p>
                <ul style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li><strong>Move task to "In Progress"</strong> â†’ MoltBot receives a work order and starts processing</li>
                    <li><strong>Add comment on Review task</strong> â†’ MoltBot sees your feedback</li>
                    <li><strong>MoltBot completes work</strong> â†’ Task moves to "Review" automatically</li>
                </ul>

                <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                    <strong>ðŸ’¡ Pro Tip:</strong> Write clear task descriptions and subtasks. The more detail you provide, the better MoltBot can execute the task.
                </div>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">âŒ¨ï¸ Keyboard Shortcuts</h2>
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 0.5rem; color: var(--text-secondary);"><code>Cmd/Ctrl + Shift + R</code></td>
                        <td style="padding: 0.5rem;">Hard refresh (clear cache)</td>
                    </tr>
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 0.5rem; color: var(--text-secondary);"><code>Escape</code></td>
                        <td style="padding: 0.5rem;">Close modals</td>
                    </tr>
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 0.5rem; color: var(--text-secondary);"><code>Enter</code></td>
                        <td style="padding: 0.5rem;">Save inline edits</td>
                    </tr>
                </table>
            </div>

            <div class="docs-section">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">â“ FAQ</h2>

                <details style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 500;">Why don't I see my changes?</summary>
                    <p style="color: var(--text-secondary); padding: 0.5rem 0 0 1rem;">
                        GitHub Pages can cache content. Try a hard refresh (Cmd+Shift+R) or open in an incognito window.
                    </p>
                </details>

                <details style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 500;">How do I create a new project?</summary>
                    <p style="color: var(--text-secondary); padding: 0.5rem 0 0 1rem;">
                        Click the âš™ï¸ Settings button (when logged in) â†’ Add a new project with ID, name, icon, and color.
                    </p>
                </details>

                <details style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 500;">Can multiple people use this?</summary>
                    <p style="color: var(--text-secondary); padding: 0.5rem 0 0 1rem;">
                        Yes! Anyone with repo access can connect their GitHub token. Changes from all users sync automatically.
                    </p>
                </details>
            </div>
        </div>
    </div><!-- END view-docs -->

    <!-- PEOPLE VIEW -->
    <div id="view-people" class="view" style="display: none;">
        <div class="people-container">
            <div class="people-header">
                <h1>ðŸ‘¥ Team</h1>
                <div class="people-stats" id="people-stats">
                    <!-- Stats filled by JS -->
                </div>
            </div>
            <div id="collaborators-container">
                <div class="people-loading">
                    <div class="spinner"></div>
                    <p>Loading collaborators...</p>
                </div>
            </div>
        </div>
    </div><!-- END view-people -->

    <!-- Auth Modal -->
    <div class="modal-overlay" id="auth-modal" onclick="if(event.target===this)hideAuthModal()">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">ðŸ” Connect to GitHub</h2>
                <button class="modal-close" onclick="hideAuthModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Connect your GitHub account to create, edit, and save tasks directly to the repository.
                </p>

                <div class="steps">
                    <div class="step">
                        <span class="step-number">1</span>
                        <div class="step-content">
                            <div class="step-title">Create a Personal Access Token</div>
                            <div class="step-description">
                                <a href="https://github.com/settings/tokens/new?scopes=repo&description=Mission%20Control%20Dashboard" target="_blank">
                                    Click here to create a token â†’
                                </a>
                            </div>
                        </div>
                    </div>
                    <div class="step">
                        <span class="step-number">2</span>
                        <div class="step-content">
                            <div class="step-title">Select "repo" scope</div>
                            <div class="step-description">This allows read/write access to repositories</div>
                        </div>
                    </div>
                    <div class="step">
                        <span class="step-number">3</span>
                        <div class="step-content">
                            <div class="step-title">Paste your token below</div>
                            <div class="step-description">The token starts with "ghp_"</div>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">GitHub Personal Access Token</label>
                    <input type="password" class="form-input" id="token-input" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" autocomplete="off">
                    <div class="form-hint">
                        ðŸ”’ Your token is stored locally and never sent anywhere except GitHub.
                    </div>
                    <div class="validation-loading" id="validation-loading">
                        <div class="spinner"></div>
                        <span>Validating token...</span>
                    </div>
                    <div class="validation-success" id="validation-success">
                        <span>âœ“</span>
                        <span>Connected as <strong id="validated-user"></strong></span>
                    </div>
                    <div class="validation-error" id="validation-error">
                        <span>âœ—</span>
                        <span id="error-message">Invalid token</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideAuthModal()">Cancel</button>
                <button class="btn btn-primary" id="btn-save-token" onclick="validateAndSaveToken()" disabled>Connect</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal" onclick="if(event.target===this)hideSettingsModal()">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title">âš™ï¸ Settings</h2>
                <button class="modal-close" onclick="hideSettingsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <h3 style="margin-bottom: 12px; font-size: 1rem;">Projects</h3>
                <div id="projects-list" class="projects-list"></div>

                <div class="add-project-form" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color);">
                    <h4 style="margin-bottom: 8px; font-size: 0.9rem;" id="project-form-title">Add New Project</h4>
                    <div style="display: grid; gap: 8px;">
                        <input type="text" class="form-input" id="new-project-id" placeholder="ID (z.B. marketing)">
                        <input type="text" class="form-input" id="new-project-name" placeholder="Name (z.B. Marketing)">
                        <div style="margin-bottom: 8px;">
                            <label style="font-size: 0.8rem; color: var(--text-secondary);">Icon</label>
                            <div class="emoji-picker" style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px;">
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸ“')">ðŸ“</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸ“Š')">ðŸ“Š</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸ’¼')">ðŸ’¼</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸš€')">ðŸš€</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸ’¡')">ðŸ’¡</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸŽ¯')">ðŸŽ¯</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸ“£')">ðŸ“£</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸ› ï¸')">ðŸ› ï¸</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸ“±')">ðŸ“±</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸŒ')">ðŸŒ</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸ’°')">ðŸ’°</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸ“')">ðŸ“</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ðŸ ')">ðŸ </button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('â¤ï¸')">â¤ï¸</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('â­')">â­</button>
                                <input type="text" class="form-input" id="new-project-icon" placeholder="or custom..." style="width: 100px; font-size: 1.1rem;">
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <label style="font-size: 0.8rem; color: var(--text-secondary);">Farbe:</label>
                            <input type="color" id="new-project-color" value="#6366f1" style="width: 50px; height: 32px; border: none; cursor: pointer; border-radius: 4px;">
                            <button class="btn btn-secondary" id="btn-cancel-project" onclick="cancelEditProject()" style="display: none;">Cancel</button>
                            <button class="btn btn-primary" id="btn-save-project" onclick="saveProject()" style="flex: 1;">+ Add Project</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Commit Modal -->
    <div class="modal-overlay" id="commit-modal" onclick="if(event.target===this)hideCommitModal()">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">ðŸ’¾ Save Changes to GitHub</h2>
                <button class="modal-close" onclick="hideCommitModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Commit Message</label>
                    <input type="text" class="form-input" id="commit-message" placeholder="Update tasks" autocomplete="off">
                    <div class="form-hint">
                        Describe what you changed (optional - will use default if empty)
                    </div>
                </div>
                <div id="changes-summary" style="margin-top: 1rem; padding: 1rem; background: var(--bg-card); border-radius: 6px; font-size: 0.875rem;">
                    <!-- Changes will be listed here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideCommitModal()">Cancel</button>
                <button class="btn btn-primary" id="btn-commit" onclick="commitChanges()">
                    <span id="commit-btn-text">Commit & Push</span>
                    <div class="spinner" id="commit-spinner" style="display: none;"></div>
                </button>
            </div>
        </div>
    </div>

    <!-- Task Edit Modal -->
    <div class="modal-overlay" id="task-modal" onclick="if(event.target===this)hideTaskModal()">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <h2 class="modal-title" id="task-modal-title">Edit Task</h2>
                <button class="modal-close" onclick="hideTaskModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Title</label>
                    <input type="text" class="form-input" id="task-title" placeholder="Task title">
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-input" id="task-description" rows="3" placeholder="Task description" style="resize: vertical;"></textarea>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div class="form-group">
                        <label class="form-label">Status</label>
                        <select class="form-input" id="task-status">
                            <option value="permanent">Permanent</option>
                            <option value="scheduled">Scheduled</option>
                            <option value="backlog">Backlog</option>
                            <option value="in_progress">In Progress</option>
                            <option value="review">Review</option>
                            <option value="done">Done</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Priority</label>
                        <select class="form-input" id="task-priority">
                            <option value="low">Low</option>
                            <option value="medium">Medium</option>
                            <option value="high">High</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Project</label>
                    <select class="form-input" id="task-project">
                        <!-- Populated dynamically from STATE.data.projects -->
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <div id="tags-chips" class="tags-chips-container" style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" class="form-input" id="new-tag-input" placeholder="Add tag..." style="flex: 1;" onkeydown="if(event.key==='Enter'){event.preventDefault();addTag();}">
                        <button class="btn btn-secondary btn-small" onclick="addTag()">+ Add</button>
                    </div>
                    <input type="hidden" id="task-tags">
                </div>

                <!-- Subtasks Section -->
                <div class="form-group" id="subtasks-section">
                    <label class="form-label">Subtasks</label>
                    <div class="subtasks-list" id="subtasks-list"></div>
                    <div class="subtask-add">
                        <input type="text" class="form-input" id="new-subtask-input" placeholder="Add new subtask...">
                        <button class="btn btn-secondary btn-small" onclick="addSubtask()">+ Add</button>
                    </div>
                </div>

                <!-- Comments Section -->
                <div class="form-group" id="comments-section">
                    <label class="form-label">Comments</label>
                    <div class="comments-list" id="comments-list"></div>
                    <div class="comment-add">
                        <textarea class="form-input" id="new-comment-input" rows="2" placeholder="Add a comment..."></textarea>
                        <button class="btn btn-secondary btn-small" onclick="addComment()">Post Comment</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" id="btn-delete-task" onclick="deleteTask()" style="margin-right: auto;">Delete</button>
                <button class="btn btn-secondary" id="btn-task-to-cron" onclick="openTaskToCronWizard(currentEditingTaskId)" title="Convert to recurring cron job">â° As Cron</button>
                <button class="btn btn-secondary" onclick="hideTaskModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveTask()">Save Task</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <script>
        // === CONFIG ===
        const CONFIG = {
            owner: 'xccanas',
            repo: 'mission-control-dashboard',
            branch: 'master',
            tasksFile: 'data/tasks.json'
        };

        // === STATE ===
        let STATE = {
            user: null,
            token: null,
            data: null,  // Loaded from GitHub or fallback
            originalData: null,  // For detecting changes
            hasUnsavedChanges: false,
            isLoading: false,
            isSaving: false,  // Prevent concurrent saves
            gatewayUrl: null  // Set via config or auto-detected
        };

        // === VERSION CHECK ===
        const VERSION_FILE = 'data/version.json';
        const VERSION_CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes
        let currentVersion = null;
        let versionCheckInterval = null;
        
        // Gateway URL detection
        function getGatewayUrl() {
            // 1. Check if manually configured
            if (STATE.gatewayUrl) return STATE.gatewayUrl;
            
            // 2. Check localStorage
            const stored = localStorage.getItem('mc_gateway_url');
            if (stored) return stored;
            
            // 3. Auto-detect for local development
            const isLocal = location.hostname === 'localhost' || 
                           location.hostname === '127.0.0.1' ||
                           location.protocol === 'file:';
            if (isLocal) return 'http://localhost:3033';
            
            // 4. Not available on remote (GitHub Pages)
            return null;
        }
        
        function setGatewayUrl(url) {
            STATE.gatewayUrl = url;
            if (url) {
                localStorage.setItem('mc_gateway_url', url);
            } else {
                localStorage.removeItem('mc_gateway_url');
            }
        }
// === EMBEDDED DATA (fallback when not logged in) ===
        const FALLBACK_DATA = {
            tasks: [
                // === PERMANENT (recurring tasks) ===
                {
                    id: "task_p01",
                    title: "Weekly backup check",
                    description: "Verify all automated backups completed successfully",
                    status: "permanent",
                    project: "devops",
                    tags: ["devops", "maintenance"],
                    subtasks: [
                        { id: "sub_001", title: "Check database backups", done: false },
                        { id: "sub_002", title: "Verify file storage sync", done: false },
                        { id: "sub_003", title: "Test restore procedure", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-15T09:00:00Z"
                },
                {
                    id: "task_p02",
                    title: "Review analytics dashboard",
                    description: "Check KPIs and identify trends or anomalies",
                    status: "permanent",
                    project: "growth",
                    tags: ["growth", "analytics"],
                    subtasks: [],
                    priority: "medium",
                    createdAt: "2026-01-15T09:00:00Z"
                },
                // === BACKLOG ===
                {
                    id: "task_001",
                    title: "Redesign landing page",
                    description: "Modern refresh with improved conversion focus and mobile-first approach",
                    status: "backlog",
                    project: "design",
                    tags: ["design", "growth"],
                    subtasks: [
                        { id: "sub_001", title: "Competitor analysis", done: false },
                        { id: "sub_002", title: "Wireframe concepts", done: false },
                        { id: "sub_003", title: "Design mockups", done: false },
                        { id: "sub_004", title: "Get stakeholder feedback", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-20T10:00:00Z"
                },
                {
                    id: "task_002",
                    title: "Plan weekend hiking trip",
                    description: "Research trails, check weather, prepare gear for Saturday adventure",
                    status: "backlog",
                    project: "personal",
                    tags: ["personal", "wellness"],
                    subtasks: [
                        { id: "sub_001", title: "Choose trail (moderate difficulty)", done: false },
                        { id: "sub_002", title: "Check weather forecast", done: false },
                        { id: "sub_003", title: "Pack essentials", done: false }
                    ],
                    priority: "low",
                    createdAt: "2026-01-25T18:00:00Z"
                },
                {
                    id: "task_003",
                    title: "Set up CI/CD pipeline",
                    description: "Automate testing and deployment for the main project repository",
                    status: "backlog",
                    project: "devops",
                    tags: ["devops", "automation"],
                    subtasks: [
                        { id: "sub_001", title: "Configure GitHub Actions", done: false },
                        { id: "sub_002", title: "Add test coverage reports", done: false },
                        { id: "sub_003", title: "Set up staging environment", done: false },
                        { id: "sub_004", title: "Document deployment process", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-22T14:00:00Z"
                },
                {
                    id: "task_004",
                    title: "Research email automation tools",
                    description: "Compare options for newsletter and drip campaigns",
                    status: "backlog",
                    project: "growth",
                    tags: ["growth", "research"],
                    subtasks: [],
                    priority: "medium",
                    createdAt: "2026-01-24T11:00:00Z"
                },
                // === IN PROGRESS ===
                {
                    id: "task_005",
                    title: "Implement dark mode",
                    description: "Add theme toggle with system preference detection and persistence",
                    status: "in_progress",
                    project: "devops",
                    tags: ["devops", "design"],
                    subtasks: [
                        { id: "sub_001", title: "Define color variables", done: true },
                        { id: "sub_002", title: "Create theme toggle component", done: true },
                        { id: "sub_003", title: "Persist preference in localStorage", done: false },
                        { id: "sub_004", title: "Test across browsers", done: false }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-23T09:00:00Z"
                },
                {
                    id: "task_006",
                    title: "Write Q1 blog post",
                    description: "Industry trends article for company blog, target 1500 words",
                    status: "in_progress",
                    project: "growth",
                    tags: ["growth", "content"],
                    subtasks: [
                        { id: "sub_001", title: "Outline key points", done: true },
                        { id: "sub_002", title: "Write first draft", done: true },
                        { id: "sub_003", title: "Add visuals and examples", done: false },
                        { id: "sub_004", title: "SEO optimization", done: false }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-21T10:00:00Z"
                },
                {
                    id: "task_007",
                    title: "Organize home office",
                    description: "Declutter desk, improve cable management, add plants",
                    status: "in_progress",
                    project: "personal",
                    tags: ["personal", "wellness"],
                    subtasks: [
                        { id: "sub_001", title: "Sort through papers", done: true },
                        { id: "sub_002", title: "Order cable organizers", done: true },
                        { id: "sub_003", title: "Buy desk plant", done: false }
                    ],
                    priority: "low",
                    createdAt: "2026-01-26T15:00:00Z"
                },
                // === REVIEW ===
                {
                    id: "task_008",
                    title: "API documentation update",
                    description: "Complete overhaul of REST API docs with examples and error codes",
                    status: "review",
                    project: "devops",
                    tags: ["devops", "documentation"],
                    subtasks: [
                        { id: "sub_001", title: "Document all endpoints", done: true },
                        { id: "sub_002", title: "Add request/response examples", done: true },
                        { id: "sub_003", title: "Include authentication guide", done: true },
                        { id: "sub_004", title: "Peer review", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-18T09:00:00Z"
                },
                {
                    id: "task_009",
                    title: "New logo concepts",
                    description: "Three variations for brand refresh, awaiting team vote",
                    status: "review",
                    project: "design",
                    tags: ["design", "branding"],
                    subtasks: [
                        { id: "sub_001", title: "Minimalist version", done: true },
                        { id: "sub_002", title: "Bold/modern version", done: true },
                        { id: "sub_003", title: "Classic refined version", done: true }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-19T11:00:00Z"
                },
                // === DONE ===
                {
                    id: "task_010",
                    title: "Fix login redirect bug",
                    description: "Users were redirected to wrong page after OAuth login",
                    status: "done",
                    project: "devops",
                    tags: ["devops", "bugfix"],
                    subtasks: [
                        { id: "sub_001", title: "Reproduce issue", done: true },
                        { id: "sub_002", title: "Identify root cause", done: true },
                        { id: "sub_003", title: "Implement fix", done: true },
                        { id: "sub_004", title: "Write regression test", done: true }
                    ],
                    priority: "high",
                    createdAt: "2026-01-17T08:00:00Z"
                },
                {
                    id: "task_011",
                    title: "Quarterly tax prep",
                    description: "Gather documents and submit to accountant",
                    status: "done",
                    project: "personal",
                    tags: ["personal", "finance"],
                    subtasks: [
                        { id: "sub_001", title: "Export bank statements", done: true },
                        { id: "sub_002", title: "Organize receipts", done: true },
                        { id: "sub_003", title: "Send to accountant", done: true }
                    ],
                    priority: "high",
                    createdAt: "2026-01-10T09:00:00Z"
                },
                {
                    id: "task_012",
                    title: "Social media content calendar",
                    description: "Plan posts for February across all platforms",
                    status: "done",
                    project: "growth",
                    tags: ["growth", "content"],
                    subtasks: [
                        { id: "sub_001", title: "Identify key dates/events", done: true },
                        { id: "sub_002", title: "Draft post ideas", done: true },
                        { id: "sub_003", title: "Schedule in buffer", done: true }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-12T14:00:00Z"
                }
            ],
            projects: [
                { id: "devops", name: "DevOps", color: "#3b82f6", icon: "ðŸ’»" },
                { id: "growth", name: "Growth", color: "#10b981", icon: "ðŸ“ˆ" },
                { id: "design", name: "Design", color: "#f59e0b", icon: "ðŸŽ¨" },
                { id: "personal", name: "Personal", color: "#8b5cf6", icon: "ðŸ " },
                { id: "wellness", name: "Wellness", color: "#ec4899", icon: "ðŸ§˜" }
            ],
            activities: [
                { type: "completed", actor: "You", task: "Social media content calendar", time: "2 hours ago" },
                { type: "moved", actor: "AI Assistant", task: "API documentation update", from: "in_progress", to: "review", time: "4 hours ago" },
                { type: "created", actor: "You", task: "Plan weekend hiking trip", time: "yesterday" },
                { type: "completed", actor: "You", task: "Fix login redirect bug", time: "2 days ago" },
                { type: "moved", actor: "AI Assistant", task: "Implement dark mode", from: "backlog", to: "in_progress", time: "3 days ago" }
            ],
            lastUpdated: new Date().toISOString()
        };
        async function loadTasksFromGitHub() {
            if (!STATE.token) {
                console.log('No token, using fallback data');
                STATE.data = JSON.parse(JSON.stringify(FALLBACK_DATA));
                return;
            }

            STATE.isLoading = true;
            showToast('success', 'ðŸ“¥ Loading tasks from GitHub...');

            try {
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`,
                    {
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error('Could not load tasks file');
                }

                const fileData = await response.json();
                // UTF-8 safe base64 decode
                const bytes = Uint8Array.from(atob(fileData.content), c => c.charCodeAt(0));
                const content = new TextDecoder().decode(bytes);
                const data = JSON.parse(content);

                STATE.data = data;
                STATE.originalData = JSON.parse(JSON.stringify(data));
                STATE.fileSha = fileData.sha;  // Needed for updates

                console.log('Loaded tasks from GitHub:', data.tasks.length, 'tasks');
                showToast('success', `âœ“ Loaded ${data.tasks.length} tasks from GitHub`);

            } catch (error) {
                console.error('Error loading from GitHub:', error);
                showToast('error', 'Could not load from GitHub, using cached data');
                STATE.data = JSON.parse(JSON.stringify(FALLBACK_DATA));
            }

            STATE.isLoading = false;
            renderAll();
        }

        async function saveTasksToGitHub(commitMessage) {
            if (!STATE.token || !STATE.data) {
                showToast('error', 'Not logged in');
                return false;
            }

            // Prevent duplicate saves
            if (STATE.isSaving) {
                console.log('Save already in progress, skipping duplicate');
                return false;
            }

            STATE.isSaving = true;

            try {
                // Add timeout to prevent freezing (10 second timeout)
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Save operation timed out')), 10000);
                });

                const content = btoa(unescape(encodeURIComponent(JSON.stringify(STATE.data, null, 2))));

                // If we don't have a SHA, fetch the current one first
                if (!STATE.fileSha) {
                    console.log('No SHA available, fetching current file state...');
                    const shaSuccess = await refreshFileSha();
                    if (!shaSuccess) {
                        throw new Error('Could not get current file version');
                    }
                }

                const response = await Promise.race([
                    fetch(
                        `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`,
                        {
                            method: 'PUT',
                            headers: {
                                'Authorization': `token ${STATE.token}`,
                                'Accept': 'application/vnd.github.v3+json',
                                'Content-Type': 'application/json',
                                'X-Requested-With': 'XMLHttpRequest'
                            },
                            body: JSON.stringify({
                                message: commitMessage || 'Update tasks via Mission Control',
                                content: content,
                                sha: STATE.fileSha,
                                branch: CONFIG.branch
                            })
                        }
                    ),
                    timeoutPromise
                ]);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to save');
                }

                const result = await response.json();
                STATE.fileSha = result.content.sha;
                STATE.originalData = JSON.parse(JSON.stringify(STATE.data));
                STATE.hasUnsavedChanges = false;
                document.getElementById('unsaved-banner').classList.remove('visible');

                showToast('success', 'âœ“ Saved to GitHub!');
                return true;

            } catch (error) {
                console.error('Error saving to GitHub:', error);

                // Handle specific GitHub API errors
                if (error.message && error.message.includes('422')) {
                    showToast('error', 'Save failed: SHA mismatch. Refreshing and retrying...');
                    // Clear SHA to force refresh on next attempt
                    STATE.fileSha = null;
                } else if (error.message && error.message.includes('403')) {
                    showToast('error', 'Save failed: Permission denied. Check your token.');
                } else if (error.message && error.message.includes('timed out')) {
                    showToast('error', 'Save timed out. Please try again.');
                } else {
                    showToast('error', `Failed to save: ${error.message}`);
                }

                return false;
            } finally {
                STATE.isSaving = false;
            }
        }

        // Helper function to refresh file SHA before saving
        async function refreshFileSha() {
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`,
                    {
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );

                if (!response.ok) {
                    return false;
                }

                const fileData = await response.json();
                STATE.fileSha = fileData.sha;
                return true;
            } catch (e) {
                console.error('Failed to refresh SHA:', e);
                return false;
            }
        }

        function renderAll() {
            renderFilters();
            renderTasks();
            renderCrons();
            renderTemplates();
            renderScheduledTasks();
            renderActivity();
            updateStats();
            updateProjectDropdown();
        }

        // === CRON RENDERING ===
        async function loadCronsFromGitHub() {
            try {
                const token = STATE.token || localStorage.getItem('gh_token');
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/data/crons.json`,
                    { headers: { 'Authorization': `token ${token}` } }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const content = JSON.parse(decodeURIComponent(escape(atob(data.content))));
                    STATE.crons = content.crons || [];
                    STATE.cronsSha = data.sha; // Save SHA for later updates
                    renderCrons();
                }
            } catch (e) {
                console.log('No crons.json found or error loading:', e);
                STATE.crons = [];
            }
        }
        
        // Save crons to GitHub (for fallback when Gateway unavailable)
        async function saveCronsToGitHub(commitMessage) {
            if (!STATE.token) {
                showToast('error', 'Not logged in - cannot save crons');
                return false;
            }
            
            try {
                // Add timeout to prevent freezing
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Crons save operation timed out')), 10000);
                });

                const content = btoa(unescape(encodeURIComponent(JSON.stringify({ crons: STATE.crons }, null, 2))));
                
                const response = await Promise.race([
                    fetch(
                        `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/data/crons.json`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: commitMessage || 'Update crons via Mission Control',
                            content: content,
                            sha: STATE.cronsSha,
                            branch: CONFIG.branch
                        })
                    }
                ]),
                timeoutPromise
                ]);
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to save crons');
                }
                
                const result = await response.json();
                STATE.cronsSha = result.content.sha;
                showToast('success', 'âœ“ Saved crons to GitHub!');
                return true;
                
            } catch (error) {
                console.error('Error saving crons to GitHub:', error);
                showToast('error', `Failed to save crons: ${error.message}`);
                return false;
            }
        }

        function renderCrons() {
            const container = document.getElementById('tasks-recurring');
            const countEl = document.getElementById('count-recurring');
            const crons = STATE.crons || [];
            
            countEl.textContent = crons.filter(c => c.enabled).length;
            
            if (crons.length === 0) {
                container.innerHTML = '<div class="empty-state">No recurring jobs</div>';
                return;
            }
            
            container.innerHTML = crons.map(cron => {
                const statusClass = cron.pending ? 'pending' :
                                   !cron.enabled ? 'disabled' : 
                                   cron.lastStatus === 'error' ? 'error' : 
                                   isRunning(cron) ? 'running' : 'ok';
                const statusText = cron.pending ? 'Pending sync' :
                                  !cron.enabled ? 'Disabled' :
                                  isRunning(cron) ? 'Running...' :
                                  cron.lastStatus === 'error' ? 'Error' : 'Active';
                const nextRun = cron.pending ? 'â³' : (cron.nextRunAt ? formatRelativeTime(new Date(cron.nextRunAt)) : 'N/A');
                
                return `
                    <div class="cron-card" 
                         data-cron-id="${cron.id}"
                         draggable="true"
                         ondragstart="handleCronDragStart(event, '${cron.id}')"
                         ondragend="handleCronDragEnd(event)"
                         onclick="openCronDetail('${cron.id}')">
                        <div class="cron-name">${cron.name}</div>
                        <div class="cron-schedule">${cron.scheduleHuman || cron.schedule}</div>
                        <div class="cron-status">
                            <span class="cron-status-dot ${statusClass}"></span>
                            <span>${statusText}</span>
                        </div>
                        <div class="cron-next">Next: ${nextRun}</div>
                    </div>
                `;
            }).join('');
        }

        function isRunning(cron) {
            if (!cron.nextRunAt) return false;
            const nextRun = new Date(cron.nextRunAt).getTime();
            const now = Date.now();
            // Smart running detection:
            // 1. nextRunAt is in the past (job should have started)
            // 2. Within expected duration window (avgDurationMs or fallback to 5 min)
            const expectedDuration = cron.avgDurationMs || 300000; // Default 5 minutes
            const maxRunTime = Math.max(expectedDuration, 60000); // At least 1 minute window
            return nextRun <= now && (now - nextRun) < maxRunTime;
        }

        function formatRelativeTime(date) {
            const now = new Date();
            const diff = date - now;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (diff < 0) return 'overdue';
            if (minutes < 60) return `in ${minutes}m`;
            if (hours < 24) return `in ${hours}h`;
            return `in ${days}d`;
        }

        // === AUTH FUNCTIONS ===
        function showAuthModal() {
            document.getElementById('auth-modal').classList.add('visible');
            document.getElementById('token-input').focus();
        }

        function hideAuthModal() {
            document.getElementById('auth-modal').classList.remove('visible');
            document.getElementById('token-input').value = '';
            hideValidationStates();
        }

        function hideValidationStates() {
            document.getElementById('validation-loading').classList.remove('visible');
            document.getElementById('validation-success').classList.remove('visible');
            document.getElementById('validation-error').classList.remove('visible');
        }

        async function validateAndSaveToken() {
            const token = document.getElementById('token-input').value.trim();

            if (!token) {
                showValidationError('Please enter a token');
                return;
            }

            hideValidationStates();
            document.getElementById('validation-loading').classList.add('visible');
            document.getElementById('btn-save-token').disabled = true;

            try {
                // Validate token by fetching user info
                const response = await fetch('https://api.github.com/user', {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (!response.ok) {
                    throw new Error('Invalid token');
                }

                const user = await response.json();

                // Check repo access
                const repoResponse = await fetch(`https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}`, {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (!repoResponse.ok) {
                    throw new Error('No access to repository. Make sure you have "repo" scope.');
                }

                // Success!
                document.getElementById('validation-loading').classList.remove('visible');
                document.getElementById('validation-success').classList.add('visible');
                document.getElementById('validated-user').textContent = user.login;

                // Save to localStorage
                localStorage.setItem('github_token', token);
                localStorage.setItem('github_user', JSON.stringify({
                    login: user.login,
                    avatar_url: user.avatar_url,
                    name: user.name || user.login
                }));

                STATE.token = token;
                STATE.user = user;

                // Update UI and load data
                setTimeout(async () => {
                    hideAuthModal();
                    updateAuthUI();
                    await loadTasksFromGitHub();
                    await loadCronsFromGitHub();
                }, 1000);

            } catch (error) {
                showValidationError(error.message);
            }
        }

        function showValidationError(message) {
            document.getElementById('validation-loading').classList.remove('visible');
            document.getElementById('validation-error').classList.add('visible');
            document.getElementById('error-message').textContent = message;
            document.getElementById('btn-save-token').disabled = false;
        }

        function logout() {
            localStorage.removeItem('github_token');
            localStorage.removeItem('github_user');
            STATE.token = null;
            STATE.user = null;
            STATE.data = JSON.parse(JSON.stringify(FALLBACK_DATA));
            STATE.hasUnsavedChanges = false;
            document.getElementById('unsaved-banner').classList.remove('visible');
            updateAuthUI();
            renderAll();
            showToast('success', 'Logged out');
        }

        function updateAuthUI() {
            const connectBtn = document.getElementById('btn-connect');
            const userProfile = document.getElementById('user-profile');

            if (STATE.user) {
                connectBtn.style.display = 'none';
                userProfile.style.display = 'flex';
                document.getElementById('user-avatar').src = STATE.user.avatar_url;
                document.getElementById('user-name').textContent = STATE.user.name || STATE.user.login;
            } else {
                connectBtn.style.display = 'inline-flex';
                userProfile.style.display = 'none';
            }
        }

        function checkSavedAuth() {
            const token = localStorage.getItem('github_token');
            const userJson = localStorage.getItem('github_user');

            if (token && userJson) {
                STATE.token = token;
                STATE.user = JSON.parse(userJson);
                updateAuthUI();
            }
        }

        // === TOKEN INPUT HANDLING ===
        document.getElementById('token-input').addEventListener('input', function() {
            const value = this.value.trim();
            document.getElementById('btn-save-token').disabled = !value;
            hideValidationStates();
        });

        document.getElementById('token-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                validateAndSaveToken();
            }
        });

        // === TOAST NOTIFICATIONS ===
        function showToast(type, message) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span>${type === 'success' ? 'âœ“' : 'âœ—'}</span>
                <span>${message}</span>
            `;
            container.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // === MARKDOWN RENDERER ===
        function renderMarkdown(text) {
            if (!text) return '';
            
            // Escape HTML first to prevent XSS
            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Bold: **text** or __text__
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
            
            // Italic: *text* or _text_ (but not inside words)
            html = html.replace(/(?<!\w)\*(?!\*)(.+?)(?<!\*)\*(?!\w)/g, '<em>$1</em>');
            html = html.replace(/(?<!\w)_(?!_)(.+?)(?<!_)_(?!\w)/g, '<em>$1</em>');
            
            // Inline code: `code`
            html = html.replace(/`([^`]+)`/g, '<code style="background: var(--bg-secondary); padding: 2px 6px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">$1</code>');
            
            // Links: [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color: var(--accent-blue);">$1</a>');
            
            // URLs without markdown (auto-link)
            html = html.replace(/(^|[^"=])(https?:\/\/[^\s<]+)/g, '$1<a href="$2" target="_blank" style="color: var(--accent-blue);">$2</a>');
            
            // Checkboxes: âœ… and â˜‘ï¸ (already rendered, just style them)
            // Keep emojis as-is
            
            // Tables: | col | col |
            if (html.includes('|') && html.split('\n').some(line => line.trim().startsWith('|'))) {
                const lines = html.split('\n');
                let inTable = false;
                let tableHtml = '';
                const result = [];
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed.startsWith('|') && trimmed.endsWith('|')) {
                        if (!inTable) {
                            inTable = true;
                            tableHtml = '<table style="border-collapse: collapse; margin: 8px 0; font-size: 0.85em; width: 100%;">';
                        }
                        // Skip separator rows (|---|---|)
                        if (trimmed.match(/^\|[\s\-:]+\|$/)) continue;
                        
                        const cells = trimmed.slice(1, -1).split('|').map(c => c.trim());
                        const isHeader = !tableHtml.includes('<tr>');
                        const cellTag = isHeader ? 'th' : 'td';
                        const cellStyle = isHeader 
                            ? 'style="border: 1px solid var(--border); padding: 6px 10px; background: var(--bg-secondary); text-align: left;"'
                            : 'style="border: 1px solid var(--border); padding: 6px 10px;"';
                        tableHtml += `<tr>${cells.map(c => `<${cellTag} ${cellStyle}>${c}</${cellTag}>`).join('')}</tr>`;
                    } else {
                        if (inTable) {
                            inTable = false;
                            tableHtml += '</table>';
                            result.push(tableHtml);
                            tableHtml = '';
                        }
                        result.push(line);
                    }
                }
                if (inTable) {
                    tableHtml += '</table>';
                    result.push(tableHtml);
                }
                html = result.join('\n');
            }
            
            // Line breaks
            html = html.replace(/\n/g, '<br>');
            
            return html;
        }

        // === RENDER FUNCTIONS ===
        function renderTasks(animate = false) {
            const columns = ['permanent', 'backlog', 'in_progress', 'review', 'done'];
            const data = STATE.data || FALLBACK_DATA;
            const priorityOrder = { high: 0, medium: 1, low: 2 };

            // FLIP Animation: Capture old positions
            const oldPositions = {};
            if (animate) {
                document.querySelectorAll('.task-card').forEach(card => {
                    const taskId = card.getAttribute('data-task-id');
                    if (taskId) {
                        oldPositions[taskId] = card.getBoundingClientRect();
                    }
                });
            }

            columns.forEach(status => {
                const container = document.getElementById(`tasks-${status}`);
                let tasks = data.tasks.filter(t => t.status === status && !t.isTemplate && t.status !== 'scheduled');

                // Filter out archived tasks (unless searching with archive enabled)
                if (!(showArchivedInSearch && searchQuery)) {
                    tasks = tasks.filter(t => !t.archived);
                }

                // Apply project filter
                if (currentFilter !== 'all') {
                    tasks = tasks.filter(t => t.project === currentFilter || (t.tags && t.tags.includes(currentFilter)));
                }

                // Sort: Done column by completedAt (newest first), others by priority + sortOrder
                if (status === 'done') {
                    // Done: newest completed tasks first
                    tasks.sort((a, b) => {
                        const dateA = a.completedAt ? new Date(a.completedAt).getTime() : 0;
                        const dateB = b.completedAt ? new Date(b.completedAt).getTime() : 0;
                        return dateB - dateA; // Descending (newest first)
                    });
                } else {
                    // Other columns: priority first, then sortOrder
                    tasks.sort((a, b) => {
                        const prioA = priorityOrder[a.priority] ?? 1;
                        const prioB = priorityOrder[b.priority] ?? 1;
                        if (prioA !== prioB) return prioA - prioB;
                        const orderA = a.sortOrder ?? 999999;
                        const orderB = b.sortOrder ?? 999999;
                        return orderA - orderB;
                    });
                }

                const count = document.getElementById(`count-${status}`);
                count.textContent = tasks.length;
                container.innerHTML = tasks.length === 0
                    ? '<div class="empty-state">No tasks</div>'
                    : tasks.map(renderTaskCard).join('');
            });

            // FLIP Animation: Animate from old to new positions
            if (animate && Object.keys(oldPositions).length > 0) {
                document.querySelectorAll('.task-card').forEach(card => {
                    const taskId = card.getAttribute('data-task-id');
                    if (taskId && oldPositions[taskId]) {
                        const oldPos = oldPositions[taskId];
                        const newPos = card.getBoundingClientRect();
                        const deltaY = oldPos.top - newPos.top;

                        if (Math.abs(deltaY) > 5) {
                            card.style.transform = `translateY(${deltaY}px)`;
                            card.style.transition = 'none';

                            requestAnimationFrame(() => {
                                card.style.transition = 'transform 0.4s cubic-bezier(0.2, 0, 0.2, 1)';
                                card.style.transform = 'translateY(0)';
                            });
                        }
                    }
                });
            }

            updateStats();
            
            // Re-apply search filter after rendering
            if (searchQuery) {
                applySearchFilter();
            }
        }

        function renderTaskCard(task) {
            const subtasksDone = task.subtasks.filter(s => s.done).length;
            const subtasksTotal = task.subtasks.length;
            const progress = subtasksTotal > 0 ? Math.round((subtasksDone / subtasksTotal) * 100) : 0;
            const commentsCount = (task.comments || []).length;
            const isArchived = task.archived === true;

            // Review actions
            const reviewActions = task.status === 'review' ? `
                <div class="task-actions" onclick="event.stopPropagation()">
                    <button class="task-action-btn done" onclick="quickMoveTask('${task.id}', 'done')" title="Mark as Done">âœ“ Done</button>
                    <button class="task-action-btn backlog" onclick="quickMoveTask('${task.id}', 'backlog')" title="Move to Backlog">â†© Backlog</button>
                </div>
            ` : '';

            // Archive/Unarchive actions for done tasks
            const archiveActions = task.status === 'done' && !isArchived ? `
                <div class="task-actions" onclick="event.stopPropagation()">
                    <button class="task-action-btn archive" onclick="archiveTask('${task.id}')" title="Archive this task">ðŸ“¦ Archive</button>
                </div>
            ` : '';

            // Unarchive button for archived tasks
            const unarchiveActions = isArchived ? `
                <div class="task-actions" onclick="event.stopPropagation()">
                    <button class="task-action-btn unarchive" onclick="unarchiveTask('${task.id}')" title="Restore from archive">ðŸ“¤ Unarchive</button>
                </div>
            ` : '';

            // Archived badge
            const archivedBadge = isArchived ? `
                <span class="archived-badge">ðŸ“¦ Archived</span>
            ` : '';

            // Comment indicator
            const commentIndicator = commentsCount > 0 ? `
                <div class="task-comment-indicator" title="${commentsCount} comment${commentsCount > 1 ? 's' : ''}">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    <span>${commentsCount}</span>
                </div>
            ` : '';
            
            // Processing spinner (shown when agent is working on this task)
            const isProcessing = (task.processingStartedAt || task.processing) && task.status === 'in_progress';
            let processingIndicator = '';
            let processingCardClass = '';
            
            if (isProcessing) {
                const startTime = new Date(task.processingStartedAt || Date.now());
                const now = new Date();
                const minutesElapsed = Math.floor((now - startTime) / 60000);
                const isTimeout = minutesElapsed >= 30;
                
                // Format time display
                let timeDisplay = '';
                if (minutesElapsed < 1) {
                    timeDisplay = 'just started';
                } else if (minutesElapsed < 60) {
                    timeDisplay = `${minutesElapsed} min`;
                } else {
                    const hours = Math.floor(minutesElapsed / 60);
                    const mins = minutesElapsed % 60;
                    timeDisplay = `${hours}h ${mins}m`;
                }
                
                // Set card class for border effect
                processingCardClass = isTimeout ? 'processing-timeout' : 'processing-active';
                
                // Different text for cron execution tasks
                const spinnerText = task.isCronExecution ? 'Executing...' : 'Processing...';
                
                processingIndicator = `
                    <div class="task-processing${isTimeout ? ' timeout-warning' : ''}" title="${isTimeout ? 'âš ï¸ Processing for over 30 minutes!' : 'Jeannie is working on this task...'}">
                        <div class="processing-spinner"></div>
                        <span>${spinnerText}</span>
                        <span class="processing-time">(${timeDisplay})</span>
                    </div>
                `;
            }

            return `
                <div class="task-card priority-${task.priority}${isArchived ? ' archived' : ''}${processingCardClass ? ' ' + processingCardClass : ''}" data-task-id="${task.id}"
                     draggable="${!isArchived}"
                     ondragstart="handleDragStart(event, '${task.id}')"
                     ondragend="handleDragEnd(event)"
                     onclick="openTaskDetail('${task.id}')">
                    <div class="task-title">
                        <span class="task-title-text">${task.title}</span>
                        ${archivedBadge}
                    </div>
                    ${processingIndicator}
                    <div class="task-description">${task.description}</div>
                    <div class="task-meta">
                        <div class="task-tags">
                            ${task.tags.map(tag => `<span class="task-tag ${tag}">${tag}</span>`).join('')}
                        </div>
                        ${commentIndicator}
                    </div>
                    ${subtasksTotal > 0 ? `
                        <div class="task-subtasks">
                            <div class="subtask-progress">
                                <span>${subtasksDone}/${subtasksTotal}</span>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${progress}%"></div>
                                </div>
                                <span>${progress}%</span>
                            </div>
                        </div>
                    ` : ''}
                    ${reviewActions}
                    ${archiveActions}
                    ${unarchiveActions}
                </div>
            `;
        }

        function quickMoveTask(taskId, newStatus) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                const oldStatus = task.status;
                task.status = newStatus;
                // Set completedAt when moving to done
                if (newStatus === 'done') {
                    task.completedAt = new Date().toISOString();
                } else if (oldStatus === 'done') {
                    delete task.completedAt; // Remove if moving out of done
                }
                STATE.data.lastUpdated = new Date().toISOString();
                renderTasks();

                // AUTO-SAVE
                autoSave(`Move "${task.title}" â†’ ${newStatus}`);
            }
        }

        // === DRAG & DROP (Trello-style smooth) ===
        let draggedTaskId = null;
        let draggedElement = null;
        let dropTargetInfo = null;
        let lastDropTargetInfo = null;
        let dragOverThrottle = null;

        function handleDragStart(event, taskId) {
            draggedTaskId = taskId;
            draggedElement = event.target;

            // Small delay before adding dragging class for smoother pickup
            requestAnimationFrame(() => {
                event.target.classList.add('dragging');
            });

            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', taskId);
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');

            // Clear all space indicators
            document.querySelectorAll('.task-card').forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });
            document.querySelectorAll('.column-tasks').forEach(col => {
                col.classList.remove('drag-over');
            });
            document.querySelectorAll('.drop-indicator').forEach(el => {
                el.classList.remove('visible');
            });

            draggedTaskId = null;
            draggedElement = null;
            dropTargetInfo = null;
            lastDropTargetInfo = null;
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';

            // Throttle to reduce jank
            if (dragOverThrottle) return;
            dragOverThrottle = setTimeout(() => { dragOverThrottle = null; }, 50);

            const container = event.currentTarget;

            // Only add drag-over to the hovered container
            document.querySelectorAll('.column-tasks').forEach(col => {
                if (col !== container) col.classList.remove('drag-over');
            });
            container.classList.add('drag-over');

            // Find insert position based on mouse Y
            const cards = [...container.querySelectorAll('.task-card:not(.dragging)')];
            const mouseY = event.clientY;

            // Clear space classes from cards not in this container
            document.querySelectorAll('.column-tasks').forEach(col => {
                if (col !== container) {
                    col.querySelectorAll('.task-card').forEach(card => {
                        card.classList.remove('make-space-above', 'make-space-below');
                    });
                }
            });

            // Find which card we're hovering over/between
            let insertBeforeId = null;
            let insertIndex = cards.length;
            let targetCard = null;

            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                const rect = card.getBoundingClientRect();
                const cardMiddle = rect.top + rect.height / 2;

                if (mouseY < cardMiddle) {
                    insertBeforeId = card.getAttribute('data-task-id');
                    insertIndex = i;
                    targetCard = card;
                    break;
                }
            }

            // Check if position changed
            const newDropInfo = JSON.stringify({ insertBeforeId, insertIndex, containerId: container.id });
            if (newDropInfo === JSON.stringify(lastDropTargetInfo)) return;
            lastDropTargetInfo = { insertBeforeId, insertIndex, containerId: container.id };

            // Clear all space classes in this container first
            cards.forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });

            // Add space above the target card (Trello-style gap opening)
            if (targetCard) {
                targetCard.classList.add('make-space-above');
            }

            dropTargetInfo = { insertBeforeId, insertIndex };
        }

        function handleDragLeave(event) {
            // Only remove if actually leaving the container (not entering a child)
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX;
            const y = event.clientY;

            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                event.currentTarget.classList.remove('drag-over');
                event.currentTarget.querySelectorAll('.task-card').forEach(card => {
                    card.classList.remove('make-space-above', 'make-space-below');
                });
            }
        }

        function handleDrop(event, newStatus) {
            event.preventDefault();

            const container = event.currentTarget;
            container.classList.remove('drag-over');

            // Clear all spacing classes
            document.querySelectorAll('.task-card').forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });

            if (!draggedTaskId || !STATE.user) return;

            const task = STATE.data.tasks.find(t => t.id === draggedTaskId);
            if (!task) return;

            const oldStatus = task.status;
            const statusChanged = task.status !== newStatus;
            task.status = newStatus;

            // Set completedAt when moving to done
            if (newStatus === 'done') {
                task.completedAt = new Date().toISOString();
            } else if (oldStatus === 'done') {
                delete task.completedAt;
            }

            // Calculate new sortOrder based on drop position
            const priorityOrder = { high: 0, medium: 1, low: 2 };
            let tasksInColumn = STATE.data.tasks
                .filter(t => t.status === newStatus && t.id !== task.id)
                .sort((a, b) => {
                    const prioA = priorityOrder[a.priority] ?? 1;
                    const prioB = priorityOrder[b.priority] ?? 1;
                    if (prioA !== prioB) return prioA - prioB;
                    return (a.sortOrder ?? 999999) - (b.sortOrder ?? 999999);
                });

            // Find insert position
            let insertIdx = tasksInColumn.length;
            if (dropTargetInfo?.insertBeforeId) {
                const targetIdx = tasksInColumn.findIndex(t => t.id === dropTargetInfo.insertBeforeId);
                if (targetIdx >= 0) insertIdx = targetIdx;
            }

            // Insert task at position
            tasksInColumn.splice(insertIdx, 0, task);

            // Recalculate sortOrder for all tasks in this column (within same priority groups)
            let currentPriority = null;
            let orderCounter = 0;
            tasksInColumn.forEach(t => {
                if (t.priority !== currentPriority) {
                    currentPriority = t.priority;
                    orderCounter = 0;
                }
                t.sortOrder = orderCounter++;
            });

            STATE.data.lastUpdated = new Date().toISOString();

            // Add activity if status changed
            if (statusChanged) {
                STATE.data.activities = STATE.data.activities || [];
                STATE.data.activities.unshift({
                    type: 'moved',
                    actor: STATE.user?.login || 'User',
                    task: task.title,
                    from: oldStatus,
                    to: newStatus,
                    time: 'just now'
                });
                renderActivity();
            }

            // Smooth re-render without full board animation
            renderTasksSmooth(oldStatus, newStatus, task.id);

            // AUTO-SAVE
            const action = statusChanged
                ? `Move "${task.title}" â†’ ${newStatus}`
                : `Reorder "${task.title}"`;
            autoSave(action);

            dropTargetInfo = null;
            lastDropTargetInfo = null;
        }

        // Smooth render that only animates affected columns
        function renderTasksSmooth(oldStatus, newStatus, movedTaskId) {
            const affectedColumns = oldStatus === newStatus
                ? [newStatus]
                : [oldStatus, newStatus];

            const priorityOrder = { high: 0, medium: 1, low: 2 };
            const data = STATE.data || FALLBACK_DATA;

            // Capture old positions for FLIP animation
            const oldPositions = {};
            affectedColumns.forEach(status => {
                const container = document.getElementById(`tasks-${status}`);
                container.querySelectorAll('.task-card').forEach(card => {
                    const taskId = card.getAttribute('data-task-id');
                    if (taskId) {
                        oldPositions[taskId] = card.getBoundingClientRect();
                    }
                });
            });

            // Re-render only affected columns
            affectedColumns.forEach(status => {
                const container = document.getElementById(`tasks-${status}`);
                let tasks = data.tasks.filter(t => t.status === status);

                // Apply project filter
                if (currentFilter !== 'all') {
                    tasks = tasks.filter(t => t.project === currentFilter || (t.tags && t.tags.includes(currentFilter)));
                }

                // Sort: Done column by completedAt (newest first), others by priority + sortOrder
                if (status === 'done') {
                    tasks.sort((a, b) => {
                        const dateA = a.completedAt ? new Date(a.completedAt).getTime() : 0;
                        const dateB = b.completedAt ? new Date(b.completedAt).getTime() : 0;
                        return dateB - dateA;
                    });
                } else {
                    tasks.sort((a, b) => {
                        const prioA = priorityOrder[a.priority] ?? 1;
                        const prioB = priorityOrder[b.priority] ?? 1;
                        if (prioA !== prioB) return prioA - prioB;
                        return (a.sortOrder ?? 999999) - (b.sortOrder ?? 999999);
                    });
                }

                // Update count
                const count = document.getElementById(`count-${status}`);
                count.textContent = tasks.length;

                // Disable transitions during DOM update
                container.classList.add('no-transition');
                container.innerHTML = tasks.length === 0
                    ? '<div class="empty-state">No tasks</div>'
                    : tasks.map(renderTaskCard).join('');

                // Force reflow
                container.offsetHeight;
                container.classList.remove('no-transition');
            });

            // FLIP animation for smooth movement
            requestAnimationFrame(() => {
                affectedColumns.forEach(status => {
                    const container = document.getElementById(`tasks-${status}`);
                    container.querySelectorAll('.task-card').forEach(card => {
                        const taskId = card.getAttribute('data-task-id');
                        if (taskId && oldPositions[taskId]) {
                            const oldPos = oldPositions[taskId];
                            const newPos = card.getBoundingClientRect();
                            // Only animate Y-axis (vertical) - no horizontal movement
                            const deltaY = oldPos.top - newPos.top;

                            if (Math.abs(deltaY) > 5) {
                                card.style.transform = `translateY(${deltaY}px)`;
                                card.style.transition = 'none';

                                requestAnimationFrame(() => {
                                    card.style.transition = 'transform 0.25s cubic-bezier(0.2, 0, 0.2, 1)';
                                    card.style.transform = 'translateY(0)';
                                });
                            }
                        } else if (taskId === movedTaskId) {
                            // New card entering - just fade in, no scale
                            card.style.opacity = '0';
                            requestAnimationFrame(() => {
                                card.style.transition = 'opacity 0.2s ease';
                                card.style.opacity = '1';
                            });
                        }
                    });
                });
            });

            updateStats();
        }

        // === AUTO-SAVE FUNCTION ===
        let saveInProgress = false;
        let pendingSave = null;

        async function autoSave(action) {
            if (!STATE.token || !STATE.user) {
                showToast('warning', 'Not logged in - changes not saved');
                markAsChanged();
                return;
            }

            // Prevent concurrent saves
            if (saveInProgress) {
                pendingSave = action;
                console.log('Save in progress, queuing:', action);
                return;
            }

            saveInProgress = true;
            const commitMessage = `${action} (via Mission Control)`;
            showToast('info', 'ðŸ’¾ Saving...');

            try {
                const success = await saveTasksToGitHub(commitMessage);
                if (!success) {
                    markAsChanged(); // Show "unsaved changes" if failed
                }
            } catch (error) {
                console.error('AutoSave error:', error);
                showToast('error', 'Save failed: ' + error.message);
                markAsChanged();
            } finally {
                saveInProgress = false;

                // Process pending save if any
                if (pendingSave) {
                    const nextAction = pendingSave;
                    pendingSave = null;
                    setTimeout(() => autoSave(nextAction), 100);
                }
            }
        }

        function renderActivity() {
            const container = document.getElementById('activity-list');
            const data = STATE.data || FALLBACK_DATA;
            const activities = data.activities || FALLBACK_DATA.activities;
            container.innerHTML = activities.map(a => `
                <div class="activity-item">
                    <div class="activity-dot ${a.type}"></div>
                    <div class="activity-content">
                        <span class="activity-actor">${a.actor}</span>
                        <span class="activity-action">${getActionText(a)}</span>
                        <span class="activity-task">${a.task}</span>
                        <div class="activity-time">${a.time}</div>
                    </div>
                </div>
            `).join('');
        }

        function getActionText(activity) {
            switch(activity.type) {
                case 'created': return ' created ';
                case 'moved': return ` moved to ${activity.to} `;
                case 'completed': return ' completed ';
                case 'deleted': return ' deleted ';
                case 'archive': return ' archived ';
                case 'unarchive': return ' unarchived ';
                default: return ' updated ';
            }
        }

        // Add activity to the activity feed
        function addActivity(text, type = 'updated') {
            STATE.data.activities = STATE.data.activities || [];
            
            // Parse the text to extract task name (format: "ðŸ“¦ Archived: Task Name" or similar)
            const taskMatch = text.match(/:\s*(.+)$/) || text.match(/Archived\s+\d+\s+tasks?/);
            const taskName = taskMatch ? taskMatch[1] || taskMatch[0] : text;
            
            STATE.data.activities.unshift({
                type: type,
                actor: STATE.user?.login || 'User',
                task: taskName,
                time: 'just now'
            });
            
            renderActivity();
        }

        function renderFilters() {
            const container = document.getElementById('filters');
            const data = STATE.data || FALLBACK_DATA;
            const projects = data.projects || FALLBACK_DATA.projects;
            const projectButtons = projects.map(p =>
                `<button class="filter-btn" data-filter="${p.id}" onclick="filterByProject('${p.id}')">${p.icon} ${p.name}</button>`
            ).join('');
            container.innerHTML = `
                <button class="filter-btn active" data-filter="all" onclick="filterByProject('all')">All projects</button>
                ${projectButtons}
            `;
        }

        let currentFilter = 'all';
        let searchQuery = '';
        let showArchivedInSearch = false;

        // === ARCHIVE FUNCTIONS ===
        function archiveTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                task.archived = true;
                task.archivedAt = new Date().toISOString();
                addActivity(`ðŸ“¦ Archived: ${task.title}`, 'archive');
                renderTasks();
                saveToGitHub();
            }
        }

        function unarchiveTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                delete task.archived;
                delete task.archivedAt;
                // Move back to done or backlog
                task.status = 'done';
                addActivity(`ðŸ“¤ Unarchived: ${task.title}`, 'unarchive');
                renderTasks();
                saveToGitHub();
            }
        }

        function archiveAllDone() {
            const doneTasks = STATE.data.tasks.filter(t => t.status === 'done' && !t.archived);
            if (doneTasks.length === 0) {
                showToast('No tasks to archive', 'info');
                return;
            }
            
            const count = doneTasks.length;
            doneTasks.forEach(task => {
                task.archived = true;
                task.archivedAt = new Date().toISOString();
            });
            
            addActivity(`ðŸ“¦ Archived ${count} task${count > 1 ? 's' : ''} from Done`, 'archive');
            renderTasks();
            autoSave(`Archive ${count} task${count > 1 ? 's' : ''}`);
            showToast(`Archived ${count} task${count > 1 ? 's' : ''}`, 'success');
            
            // Check if we need to move old tasks to archive files
            checkAndMoveOldArchivedTasks();
        }
        
        // === TASK 6: ARCHIV-STRATEGIE ===
        let archivedTasksLoaded = false;
        let archiveIndex = null;
        
        async function checkAndMoveOldArchivedTasks() {
            const now = new Date();
            const cutoffDate = new Date(now.getTime() - (90 * 24 * 60 * 60 * 1000)); // 90 days ago
            
            const oldArchivedTasks = STATE.data.tasks.filter(t => 
                t.archived && 
                t.archivedAt && 
                new Date(t.archivedAt) < cutoffDate
            );
            
            if (oldArchivedTasks.length === 0) return;
            
            // Group by month
            const byMonth = {};
            oldArchivedTasks.forEach(task => {
                const date = new Date(task.archivedAt);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!byMonth[key]) byMonth[key] = [];
                byMonth[key].push(task);
            });
            
            console.log(`Moving ${oldArchivedTasks.length} old archived tasks to archive files`);
            
            // For now, just mark them as offloaded (actual file operations would need backend)
            oldArchivedTasks.forEach(task => {
                task.offloadedToArchive = true;
            });
            
            // Update archive index
            await updateArchiveIndex(byMonth);
        }
        
        async function updateArchiveIndex(byMonth) {
            if (!archiveIndex) {
                archiveIndex = { archives: {}, lastUpdated: null };
            }
            
            Object.keys(byMonth).forEach(monthKey => {
                if (!archiveIndex.archives[monthKey]) {
                    archiveIndex.archives[monthKey] = { count: 0, tasks: [] };
                }
                archiveIndex.archives[monthKey].count += byMonth[monthKey].length;
                archiveIndex.archives[monthKey].tasks.push(...byMonth[monthKey].map(t => ({
                    id: t.id,
                    title: t.title,
                    archivedAt: t.archivedAt
                })));
            });
            
            archiveIndex.lastUpdated = new Date().toISOString();
        }
        
        async function loadArchivedTasks() {
            if (archivedTasksLoaded) return;
            
            showToast('info', 'Loading archived tasks...');
            
            try {
                // Load archive index from GitHub
                const token = STATE.token || localStorage.getItem('gh_token');
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/archive/archive-index.json`,
                    { headers: { 'Authorization': `token ${token}` } }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    archiveIndex = JSON.parse(atob(data.content));
                    archivedTasksLoaded = true;
                    showToast('success', `Loaded archive index`);
                }
            } catch (e) {
                console.log('No archive index found or error:', e);
            }
        }
        
        function exportArchivedTasksCSV() {
            const archivedTasks = STATE.data.tasks.filter(t => t.archived);
            
            if (archivedTasks.length === 0) {
                showToast('info', 'No archived tasks to export');
                return;
            }
            
            // CSV Header
            const headers = ['ID', 'Title', 'Description', 'Status', 'Priority', 'Project', 'Tags', 'Created', 'Completed', 'Archived'];
            
            // CSV Rows
            const rows = archivedTasks.map(task => [
                task.id,
                `"${(task.title || '').replace(/"/g, '""')}"`,
                `"${(task.description || '').replace(/"/g, '""').replace(/\n/g, ' ')}"`,
                task.status,
                task.priority,
                task.project || '',
                (task.tags || []).join(';'),
                task.createdAt || '',
                task.completedAt || '',
                task.archivedAt || ''
            ]);
            
            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `archived-tasks-${new Date().toISOString().slice(0, 10)}.csv`;
            link.click();
            
            showToast('success', `Exported ${archivedTasks.length} archived tasks to CSV`);
        }
        
        function showArchiveView() {
            // Load archived tasks if not already loaded
            loadArchivedTasks();
            
            const archivedTasks = STATE.data.tasks.filter(t => t.archived);
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'archive-view-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 700px; max-height: 80vh;">
                    <div class="modal-header">
                        <h2 class="modal-title">ðŸ“¦ Archive (${archivedTasks.length} tasks)</h2>
                        <button class="modal-close" onclick="closeArchiveView()">&times;</button>
                    </div>
                    <div class="modal-body" style="overflow-y: auto; max-height: 50vh;">
                        ${archivedTasks.length === 0 ? '<div class="empty-state">No archived tasks</div>' : 
                          archivedTasks.map(task => `
                            <div style="padding: 0.75rem; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>${task.title}</strong>
                                    <div style="font-size: 0.8rem; color: var(--text-secondary);">
                                        Archived: ${new Date(task.archivedAt).toLocaleDateString()}
                                    </div>
                                </div>
                                <button class="btn btn-secondary btn-small" onclick="unarchiveTask('${task.id}'); closeArchiveView();">
                                    ðŸ“¤ Restore
                                </button>
                            </div>
                          `).join('')
                        }
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="exportArchivedTasksCSV()">ðŸ“¥ Export CSV</button>
                        <button class="btn btn-primary" onclick="closeArchiveView()">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }
        
        function closeArchiveView() {
            const dialog = document.getElementById('archive-view-dialog');
            if (dialog) dialog.remove();
        }

        function toggleArchiveSearch(enabled) {
            showArchivedInSearch = enabled;
            renderTasks();
            if (searchQuery) {
                applySearchFilter();
            }
        }

        function handleSearch(query) {
            searchQuery = query.toLowerCase().trim();
            
            // Re-render tasks if archive search is enabled (to show/hide archived tasks)
            if (showArchivedInSearch) {
                renderTasks();
            }
            
            applySearchFilter();
            
            const searchInput = document.getElementById('search-input');
            const clearBtn = document.querySelector('.search-clear');
            
            // Keep expanded when has content
            if (searchInput) {
                searchInput.classList.toggle('expanded', query.length > 0);
            }
            
            // Toggle clear button visibility
            if (clearBtn) {
                clearBtn.style.display = query.length > 0 ? 'block' : 'none';
            }
        }

        function applySearchFilter() {
            const cards = document.querySelectorAll('.task-card');
            const data = STATE.data || FALLBACK_DATA;
            
            cards.forEach(card => {
                const taskId = card.getAttribute('data-task-id');
                const task = data.tasks.find(t => t.id === taskId);
                
                if (!task || !searchQuery) {
                    card.classList.remove('search-dimmed');
                    return;
                }
                
                // Search in title, description, tags, and comments
                const titleMatch = task.title.toLowerCase().includes(searchQuery);
                const descMatch = task.description.toLowerCase().includes(searchQuery);
                const tagMatch = task.tags.some(tag => tag.toLowerCase().includes(searchQuery));
                const commentMatch = task.comments && task.comments.some(c => 
                    c.text.toLowerCase().includes(searchQuery) || 
                    c.author.toLowerCase().includes(searchQuery)
                );
                
                if (titleMatch || descMatch || tagMatch || commentMatch) {
                    card.classList.remove('search-dimmed');
                } else {
                    card.classList.add('search-dimmed');
                }
            });
            
            // Update search result count
            const matchCount = document.querySelectorAll('.task-card:not(.search-dimmed)').length;
            const totalCount = cards.length;
            const searchInfo = document.getElementById('search-info');
            if (searchInfo) {
                if (searchQuery) {
                    searchInfo.textContent = `${matchCount}/${totalCount}`;
                    searchInfo.style.display = 'inline';
                } else {
                    searchInfo.style.display = 'none';
                }
            }
        }

        function clearSearch() {
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                searchInput.value = '';
                searchInput.classList.remove('expanded');
                searchInput.blur();
            }
            searchQuery = '';
            
            // Re-render to hide archived tasks when search is cleared
            if (showArchivedInSearch) {
                renderTasks();
            }
            
            applySearchFilter();
        }

        function filterByProject(projectId) {
            currentFilter = projectId;

            // Update active state
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === projectId);
            });

            renderTasks();
        }

        function updateStats() {
            const data = STATE.data || FALLBACK_DATA;
            // Exclude archived tasks from stats
            const activeTasks = data.tasks.filter(t => !t.archived);
            const total = activeTasks.filter(t => t.status !== 'permanent').length;
            const inProgress = activeTasks.filter(t => t.status === 'in_progress').length;
            const review = activeTasks.filter(t => t.status === 'review').length;
            const completion = total > 0 ? Math.round((review / total) * 100) : 0;

            document.getElementById('stat-total').textContent = total;
            document.getElementById('stat-progress').textContent = inProgress;
            document.getElementById('stat-week').textContent = review;
            document.getElementById('stat-completion').textContent = completion + '%';
        }

        // === TASK EDITING ===
        let currentEditingTaskId = null;
        let currentTaskTags = [];

        // === TAG FUNCTIONS ===
        function renderTagChips() {
            const container = document.getElementById('tags-chips');
            if (!container) return;

            if (currentTaskTags.length === 0) {
                container.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.875rem;">No tags</span>';
                return;
            }

            container.innerHTML = currentTaskTags.map(tag => `
                <span class="tag-chip">
                    ${tag}
                    <span class="tag-remove" onclick="removeTag('${tag}')" title="Remove">âœ•</span>
                </span>
            `).join('');
        }

        function addTag() {
            const input = document.getElementById('new-tag-input');
            const tag = input.value.trim().toLowerCase();
            if (!tag) return;

            if (!currentTaskTags.includes(tag)) {
                currentTaskTags.push(tag);
                renderTagChips();
            }
            input.value = '';
        }

        function removeTag(tag) {
            currentTaskTags = currentTaskTags.filter(t => t !== tag);
            renderTagChips();
        }

        function openTaskDetail(taskId) {
            if (!STATE.user) {
                showToast('error', 'Login to edit tasks');
                return;
            }

            const data = STATE.data || FALLBACK_DATA;
            const task = data.tasks.find(t => t.id === taskId);

            if (!task) {
                showToast('error', 'Task not found');
                return;
            }

            currentEditingTaskId = taskId;
            isEditingTemplate = task.isTemplate === true;

            // Populate modal
            document.getElementById('task-modal-title').textContent = task.isTemplate ? 'ðŸ“‘ Edit Template' : 'Edit Task';
            document.getElementById('task-title').value = task.title;
            document.getElementById('task-description').value = task.description;
            document.getElementById('task-status').value = task.isTemplate ? (task.baseStatus || 'backlog') : task.status;
            document.getElementById('task-priority').value = task.priority;
            document.getElementById('task-project').value = task.project;
            document.getElementById('btn-delete-task').style.display = 'block';
            
            // Show/hide "As Cron" button based on task type
            const asCronBtn = document.getElementById('btn-task-to-cron');
            if (asCronBtn) {
                asCronBtn.style.display = task.isTemplate ? 'none' : 'inline-flex';
            }

            // Render tags as chips
            currentTaskTags = [...(task.tags || [])];
            renderTagChips();

            // Render subtasks
            renderSubtasks(task);

            // Render comments
            renderComments(task);

            document.getElementById('task-modal').classList.add('visible');
        }

        function renderSubtasks(task) {
            const container = document.getElementById('subtasks-list');
            if (!task.subtasks || task.subtasks.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No subtasks yet</div>';
                return;
            }
            container.innerHTML = task.subtasks.map(sub => `
                <div class="subtask-item">
                    <input type="checkbox" ${sub.done ? 'checked' : ''} onchange="toggleSubtask('${task.id}', '${sub.id}')">
                    <span class="subtask-title ${sub.done ? 'done' : ''}"
                          onclick="startEditSubtask('${task.id}', '${sub.id}')"
                          title="Click to edit"
                          style="cursor: pointer;">${sub.title}</span>
                    <button class="subtask-delete" onclick="deleteSubtask('${task.id}', '${sub.id}')" title="Delete">âœ•</button>
                </div>
            `).join('');
        }

        function startEditSubtask(taskId, subtaskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            const subtask = task.subtasks.find(s => s.id === subtaskId);
            if (!subtask) return;

            // Replace span with input
            const container = document.getElementById('subtasks-list');
            const items = container.querySelectorAll('.subtask-item');
            items.forEach(item => {
                const span = item.querySelector('.subtask-title');
                if (span && span.textContent === subtask.title) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = subtask.title;
                    input.className = 'subtask-edit-input';
                    input.style.cssText = 'flex: 1; padding: 4px 8px; border: 1px solid var(--accent); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary);';

                    input.onblur = () => saveSubtaskEdit(taskId, subtaskId, input.value);
                    input.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            saveSubtaskEdit(taskId, subtaskId, input.value);
                        }
                        if (e.key === 'Escape') {
                            renderSubtasks(task);
                        }
                    };

                    span.replaceWith(input);
                    input.focus();
                    input.select();
                }
            });
        }

        function saveSubtaskEdit(taskId, subtaskId, newTitle) {
            newTitle = newTitle.trim();
            if (!newTitle) return;

            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            const subtask = task.subtasks.find(s => s.id === subtaskId);
            if (!subtask) return;

            if (subtask.title !== newTitle) {
                const oldTitle = subtask.title;
                subtask.title = newTitle;
                renderSubtasks(task);
                // AUTO-SAVE
                autoSave(`Rename subtask "${oldTitle}" â†’ "${newTitle}"`);
            } else {
                renderSubtasks(task);
            }
        }

        function renderComments(task) {
            const container = document.getElementById('comments-list');
            const comments = task.comments || [];
            if (comments.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No comments yet</div>';
                return;
            }
            container.innerHTML = comments.map((c, idx) => `
                <div class="comment-item" data-comment-idx="${idx}">
                    <div class="comment-header">
                        <span class="comment-author">${c.author}</span>
                        <span class="comment-time">${formatTimeAgo(c.createdAt)}</span>
                        <span class="comment-actions">
                            <button class="comment-action-btn" onclick="editComment('${task.id}', ${idx})" title="Edit">âœï¸</button>
                            <button class="comment-action-btn" onclick="deleteComment('${task.id}', ${idx})" title="Delete">ðŸ—‘ï¸</button>
                        </span>
                    </div>
                    <div class="comment-text" id="comment-text-${idx}">${renderMarkdown(c.text)}</div>
                </div>
            `).join('');
        }

        function editComment(taskId, commentIdx) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.comments || !task.comments[commentIdx]) return;

            const comment = task.comments[commentIdx];
            const textEl = document.getElementById(`comment-text-${commentIdx}`);
            if (!textEl) return;

            const textarea = document.createElement('textarea');
            textarea.value = comment.text;
            textarea.className = 'comment-edit-textarea';
            textarea.style.cssText = 'width: 100%; min-height: 60px; padding: 8px; border: 1px solid var(--accent); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary); resize: vertical;';

            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.className = 'btn btn-primary btn-small';
            saveBtn.style.marginTop = '8px';
            saveBtn.onclick = () => saveCommentEdit(taskId, commentIdx, textarea.value);

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'btn btn-secondary btn-small';
            cancelBtn.style.cssText = 'margin-top: 8px; margin-left: 8px;';
            cancelBtn.onclick = () => renderComments(task);

            textEl.innerHTML = '';
            textEl.appendChild(textarea);
            textEl.appendChild(saveBtn);
            textEl.appendChild(cancelBtn);
            textarea.focus();
        }

        function saveCommentEdit(taskId, commentIdx, newText) {
            newText = newText.trim();
            if (!newText) return;

            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.comments || !task.comments[commentIdx]) return;

            const oldText = task.comments[commentIdx].text;
            if (oldText !== newText) {
                task.comments[commentIdx].text = newText;
                task.comments[commentIdx].editedAt = new Date().toISOString();
                renderComments(task);
                autoSave(`Edit comment on "${task.title}"`);
            } else {
                renderComments(task);
            }
        }

        function deleteComment(taskId, commentIdx) {
            if (!confirm('Delete this comment?')) return;

            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.comments) return;

            task.comments.splice(commentIdx, 1);
            renderComments(task);
            autoSave(`Delete comment from "${task.title}"`);
        }

        function formatTimeAgo(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffMs = now - date;
            const diffMin = Math.floor(diffMs / 60000);
            const diffHour = Math.floor(diffMs / 3600000);
            const diffDay = Math.floor(diffMs / 86400000);

            if (diffMin < 1) return 'just now';
            if (diffMin < 60) return diffMin + ' min ago';
            if (diffHour < 24) return diffHour + ' hours ago';
            return diffDay + ' days ago';
        }

        function toggleSubtask(taskId, subtaskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                const subtask = task.subtasks.find(s => s.id === subtaskId);
                if (subtask) {
                    subtask.done = !subtask.done;
                    renderSubtasks(task);
                    renderTasks();
                    // AUTO-SAVE mit Debounce
                    debouncedAutoSave(`${subtask.done ? 'âœ“' : 'â—‹'} "${subtask.title}" in "${task.title}"`);
                }
            }
        }

        function deleteSubtask(taskId, subtaskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                const subtask = task.subtasks.find(s => s.id === subtaskId);
                const subtaskTitle = subtask?.title || 'Subtask';
                task.subtasks = task.subtasks.filter(s => s.id !== subtaskId);
                renderSubtasks(task);
                renderTasks();
                // AUTO-SAVE
                autoSave(`Remove subtask "${subtaskTitle}" from "${task.title}"`);
            }
        }

        function addSubtask() {
            if (!currentEditingTaskId) return;
            const input = document.getElementById('new-subtask-input');
            const title = input.value.trim();
            if (!title) return;

            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            if (task) {
                const newId = 'sub_' + Date.now();
                task.subtasks.push({ id: newId, title: title, done: false });
                renderSubtasks(task);
                renderTasks();
                input.value = '';
                // AUTO-SAVE
                autoSave(`Add subtask "${title}" to "${task.title}"`);
            }
        }

        // === DEBOUNCED AUTO-SAVE (for rapid changes) ===
        let autoSaveTimeout = null;
        function debouncedAutoSave(action) {
            if (autoSaveTimeout) clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(() => {
                autoSave(action);
            }, 1000); // 1 Sekunde warten
        }

        function addComment() {
            if (!currentEditingTaskId) return;
            const input = document.getElementById('new-comment-input');
            const text = input.value.trim();
            if (!text) return;

            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            if (task) {
                if (!task.comments) task.comments = [];
                task.comments.push({
                    id: 'c_' + Date.now(),
                    author: STATE.user?.login || 'User',
                    text: text,
                    createdAt: new Date().toISOString()
                });
                renderComments(task);
                input.value = '';

                // AUTO-SAVE mit speziellem Hinweis bei Review-Tasks
                let commitMsg = `Comment on "${task.title}": ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`;
                if (task.status === 'review') {
                    commitMsg = `ðŸ’¬ FEEDBACK on "${task.title}": ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`;
                }
                autoSave(commitMsg);
            }
        }

        function openNewTask(status = 'backlog') {
            if (!STATE.user) {
                showToast('error', 'Login to add tasks');
                return;
            }

            currentEditingTaskId = null;

            // Reset modal
            document.getElementById('task-modal-title').textContent = 'New Task';
            document.getElementById('task-title').value = '';
            document.getElementById('task-description').value = '';
            document.getElementById('task-status').value = status;
            document.getElementById('task-priority').value = 'medium';
            document.getElementById('task-project').value = 'system';
            document.getElementById('btn-delete-task').style.display = 'none';

            // Reset tags
            currentTaskTags = [];
            renderTagChips();

            // Clear subtasks and comments for new task
            document.getElementById('subtasks-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No subtasks yet</div>';
            document.getElementById('comments-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No comments yet</div>';

            document.getElementById('task-modal').classList.add('visible');
        }

        function hideTaskModal() {
            document.getElementById('task-modal').classList.remove('visible');
            currentEditingTaskId = null;
            isEditingTemplate = false;
        }

        function saveTask() {
            const title = document.getElementById('task-title').value.trim();
            const description = document.getElementById('task-description').value.trim();
            const status = document.getElementById('task-status').value;
            const priority = document.getElementById('task-priority').value;
            const project = document.getElementById('task-project').value;
            const tags = currentTaskTags.length > 0 ? [...currentTaskTags] : [project];

            if (!title) {
                showToast('error', 'Title is required');
                return;
            }

            if (currentEditingTaskId) {
                // Update existing task or template
                const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
                if (task) {
                    task.title = title;
                    task.description = description;
                    task.priority = priority;
                    task.project = project;
                    task.tags = tags.length > 0 ? tags : [project];
                    
                    if (isEditingTemplate) {
                        task.baseStatus = status; // Store the status to use when executing
                    } else {
                        task.status = status;
                    }
                }
            } else {
                // Create new task or template
                const newItem = {
                    id: (isEditingTemplate ? 'template_' : 'task_') + Date.now(),
                    title: title,
                    description: description,
                    project: project,
                    tags: tags.length > 0 ? tags : [project],
                    subtasks: [],
                    priority: priority,
                    createdAt: new Date().toISOString()
                };
                
                if (isEditingTemplate) {
                    newItem.isTemplate = true;
                    newItem.baseStatus = status;
                    newItem.executionCount = 0;
                } else {
                    newItem.status = status;
                }
                
                STATE.data.tasks.push(newItem);
            }

            STATE.data.lastUpdated = new Date().toISOString();
            hideTaskModal();
            
            if (isEditingTemplate) {
                renderTemplates();
            } else {
                renderTasks(true); // Animate reorder
            }
            
            isEditingTemplate = false;

            // AUTO-SAVE
            const itemType = isEditingTemplate ? 'template' : 'task';
            const action = currentEditingTaskId ? `Update ${itemType} "${title}"` : `Create ${itemType} "${title}"`;
            autoSave(action);
        }

        function deleteTask() {
            if (!currentEditingTaskId) return;

            if (!confirm('Are you sure you want to delete this task?')) return;

            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            const taskTitle = task?.title || 'Task';

            STATE.data.tasks = STATE.data.tasks.filter(t => t.id !== currentEditingTaskId);
            STATE.data.lastUpdated = new Date().toISOString();
            hideTaskModal();
            renderTasks();

            // AUTO-SAVE
            autoSave(`Delete "${taskTitle}"`);
        }

        function markAsChanged() {
            STATE.hasUnsavedChanges = true;
            document.getElementById('unsaved-banner').classList.add('visible');
        }

        function discardChanges() {
            if (STATE.originalData) {
                STATE.data = JSON.parse(JSON.stringify(STATE.originalData));
            }
            STATE.hasUnsavedChanges = false;
            document.getElementById('unsaved-banner').classList.remove('visible');
            renderTasks();
            showToast('success', 'Changes discarded');
        }

        // === COMMIT MODAL ===
        function showCommitModal() {
            if (!STATE.hasUnsavedChanges) {
                showToast('error', 'No changes to save');
                return;
            }

            document.getElementById('commit-message').value = '';
            document.getElementById('changes-summary').innerHTML = generateChangesSummary();
            document.getElementById('commit-modal').classList.add('visible');
        }

        function hideCommitModal() {
            document.getElementById('commit-modal').classList.remove('visible');
        }

        // === SETTINGS MODAL ===
        function showSettingsModal() {
            renderProjectsList();
            document.getElementById('settings-modal').classList.add('visible');
        }

        function hideSettingsModal() {
            document.getElementById('settings-modal').classList.remove('visible');
        }

        function renderProjectsList() {
            const container = document.getElementById('projects-list');
            const projects = STATE.data?.projects || [];

            if (projects.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary);">No projects yet</div>';
                return;
            }

            container.innerHTML = projects.map(p => `
                <div class="project-item">
                    <span class="project-icon">${p.icon}</span>
                    <span class="project-color" style="background: ${p.color}"></span>
                    <span class="project-name">${p.name}</span>
                    <span class="project-id">${p.id}</span>
                    <div class="project-actions">
                        <button onclick="editProject('${p.id}')" title="Edit">âœï¸</button>
                        <button onclick="deleteProject('${p.id}')" title="Delete">ðŸ—‘ï¸</button>
                    </div>
                </div>
            `).join('');

            // Update project dropdown in task modal
            updateProjectDropdown();
        }

        let editingProjectId = null;

        function saveProject() {
            const id = document.getElementById('new-project-id').value.trim().toLowerCase().replace(/\s+/g, '-');
            const name = document.getElementById('new-project-name').value.trim();
            const icon = document.getElementById('new-project-icon').value.trim() || 'ðŸ“';
            const color = document.getElementById('new-project-color').value;

            if (!id || !name) {
                showToast('error', 'ID and Name are required');
                return;
            }

            if (editingProjectId) {
                // UPDATE existing project
                const project = STATE.data.projects.find(p => p.id === editingProjectId);
                if (project) {
                    // If ID changed, update all tasks using this project
                    if (editingProjectId !== id) {
                        STATE.data.tasks.forEach(t => {
                            if (t.project === editingProjectId) t.project = id;
                        });
                    }
                    project.id = id;
                    project.name = name;
                    project.icon = icon;
                    project.color = color;
                    autoSave(`Update project "${name}"`);
                }
            } else {
                // ADD new project
                if (STATE.data.projects.some(p => p.id === id)) {
                    showToast('error', 'Project ID already exists');
                    return;
                }
                STATE.data.projects.push({ id, name, icon, color });
                autoSave(`Add project "${name}"`);
            }

            // Reset form
            clearProjectForm();
            renderProjectsList();
            renderFilters();
        }

        function editProject(projectId) {
            const project = STATE.data.projects.find(p => p.id === projectId);
            if (!project) return;

            // Load data into form
            editingProjectId = projectId;
            document.getElementById('new-project-id').value = project.id;
            document.getElementById('new-project-name').value = project.name;
            document.getElementById('new-project-icon').value = project.icon;
            document.getElementById('new-project-color').value = project.color;

            // Update UI
            document.getElementById('project-form-title').textContent = `Edit Project: ${project.name}`;
            document.getElementById('btn-save-project').textContent = 'ðŸ’¾ Save Changes';
            document.getElementById('btn-cancel-project').style.display = 'block';

            // Clear emoji selection
            document.querySelectorAll('.emoji-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.textContent.trim() === project.icon);
            });

            // Scroll to form
            document.querySelector('.add-project-form').scrollIntoView({ behavior: 'smooth' });
        }

        function cancelEditProject() {
            clearProjectForm();
        }

        function clearProjectForm() {
            editingProjectId = null;
            document.getElementById('new-project-id').value = '';
            document.getElementById('new-project-name').value = '';
            document.getElementById('new-project-icon').value = '';
            document.getElementById('new-project-color').value = '#6366f1';
            document.getElementById('project-form-title').textContent = 'Add New Project';
            document.getElementById('btn-save-project').textContent = '+ Add Project';
            document.getElementById('btn-cancel-project').style.display = 'none';
            document.querySelectorAll('.emoji-btn').forEach(btn => btn.classList.remove('selected'));
        }

        function deleteProject(projectId) {
            const project = STATE.data.projects.find(p => p.id === projectId);
            if (!project) return;

            // Check if any tasks use this project
            const tasksUsingProject = STATE.data.tasks.filter(t => t.project === projectId);
            if (tasksUsingProject.length > 0) {
                if (!confirm(`${tasksUsingProject.length} task(s) use this project. Delete anyway? Tasks will be moved to "system".`)) {
                    return;
                }
                // Move tasks to system
                tasksUsingProject.forEach(t => t.project = 'system');
            }

            STATE.data.projects = STATE.data.projects.filter(p => p.id !== projectId);

            renderProjectsList();
            renderFilters();
            autoSave(`Delete project "${project.name}"`);
        }

        function updateProjectDropdown() {
            const select = document.getElementById('task-project');
            if (!select) return;

            const projects = STATE.data?.projects || [];
            select.innerHTML = projects.map(p =>
                `<option value="${p.id}">${p.icon} ${p.name}</option>`
            ).join('');
        }

        function selectEmoji(emoji) {
            document.getElementById('new-project-icon').value = emoji;
            // Visual feedback
            document.querySelectorAll('.emoji-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
        }

        // === VIEW SWITCHING ===
        function switchView(viewName) {
            // Hide all views
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('.view').forEach(v => v.style.display = 'none');

            // Show selected view
            const view = document.getElementById('view-' + viewName);
            if (view) {
                view.classList.add('active');
                view.style.display = 'block';
            }

            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === viewName);
            });
        }

        function generateChangesSummary() {
            const current = STATE.data.tasks.length;
            const original = STATE.originalData ? STATE.originalData.tasks.length : current;
            const diff = current - original;

            let html = '<strong>Changes to commit:</strong><br>';
            if (diff > 0) {
                html += `â€¢ Added ${diff} new task(s)<br>`;
            } else if (diff < 0) {
                html += `â€¢ Deleted ${Math.abs(diff)} task(s)<br>`;
            }
            html += `â€¢ Total tasks: ${current}`;

            return html;
        }

        async function commitChanges() {
            const message = document.getElementById('commit-message').value.trim() || 'Update tasks via Mission Control';

            document.getElementById('commit-btn-text').textContent = 'Saving...';
            document.getElementById('commit-spinner').style.display = 'inline-block';
            document.getElementById('btn-commit').disabled = true;

            const success = await saveTasksToGitHub(message);

            document.getElementById('commit-btn-text').textContent = 'Commit & Push';
            document.getElementById('commit-spinner').style.display = 'none';
            document.getElementById('btn-commit').disabled = false;

            if (success) {
                hideCommitModal();
            }
        }

        // === ACTIVITY TOGGLE ===
        function toggleActivity() {
            const sidebar = document.getElementById('activity-sidebar');
            const icon = document.getElementById('activity-toggle-icon');
            const reopen = document.getElementById('activity-reopen');
            const isCollapsed = sidebar.classList.toggle('collapsed');
            icon.textContent = isCollapsed ? 'â˜°' : 'âœ•';
            reopen.style.display = isCollapsed ? 'flex' : 'none';
            localStorage.setItem('activity-collapsed', isCollapsed);
        }

        // === AUTO-POLLING ===
        let lastDataHash = null;
        let lastPollTime = Date.now();
        const POLL_INTERVAL = 30000; // 30 seconds

        function hashData(data) {
            return JSON.stringify(data);
        }

        async function pollForUpdates() {
            if (!STATE.token || STATE.hasUnsavedChanges || document.hidden) return;

            try {
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`,
                    {
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'If-None-Match': ''  // Bypass cache
                        }
                    }
                );

                if (!response.ok) return;

                const fileData = await response.json();
                const bytes = Uint8Array.from(atob(fileData.content), c => c.charCodeAt(0));
                const content = new TextDecoder().decode(bytes);
                const newData = JSON.parse(content);

                const newHash = hashData(newData);
                if (lastDataHash && newHash !== lastDataHash) {
                    STATE.data = newData;
                    STATE.originalData = JSON.parse(JSON.stringify(newData));
                    STATE.fileSha = fileData.sha;
                    renderAll();
                    showToast('success', 'ðŸ”„ Dashboard updated');
                }
                lastDataHash = newHash;
                lastPollTime = Date.now();
                updateLiveIndicator();

            } catch (error) {
                console.log('Poll error:', error);
            }
        }

        function updateLiveIndicator() {
            const indicator = document.getElementById('live-indicator');
            if (indicator) {
                const seconds = Math.round((Date.now() - lastPollTime) / 1000);
                indicator.textContent = seconds < 5 ? 'Live' : `${seconds}s ago`;
                indicator.className = 'live-indicator ' + (seconds < 35 ? 'live' : 'stale');
            }
        }

        // Start polling
        setInterval(pollForUpdates, POLL_INTERVAL);
        setInterval(updateLiveIndicator, 1000);

        // === TEMPLATES FUNCTIONS ===
        function renderTemplates() {
            const container = document.getElementById('tasks-templates');
            const countEl = document.getElementById('count-templates');
            const data = STATE.data || FALLBACK_DATA;
            const templates = data.tasks.filter(t => t.isTemplate === true);
            
            countEl.textContent = templates.length;
            
            if (templates.length === 0) {
                container.innerHTML = '<div class="empty-state">No templates yet</div>';
                return;
            }
            
            container.innerHTML = templates.map(template => {
                const execCount = template.executionCount || 0;
                return `
                    <div class="template-card" data-template-id="${template.id}" onclick="openTemplateDetail('${template.id}')">
                        <div class="template-name">${template.title}</div>
                        <div class="template-description">${template.description || ''}</div>
                        <div class="template-meta">
                            <span class="execution-count" title="Times executed">
                                â–¶ ${execCount}x
                            </span>
                            ${template.tags ? template.tags.map(t => `<span class="task-tag ${t}">${t}</span>`).join('') : ''}
                        </div>
                        <div class="template-actions" onclick="event.stopPropagation()">
                            <button class="template-action-btn run" onclick="executeTemplate('${template.id}')" title="Run template">â–¶ Run</button>
                            <button class="template-action-btn" onclick="duplicateTemplate('${template.id}')" title="Duplicate">ðŸ“‹ Copy</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function openNewTemplate() {
            if (!STATE.user) {
                showToast('error', 'Login to create templates');
                return;
            }
            
            currentEditingTaskId = null;
            isEditingTemplate = true;
            
            document.getElementById('task-modal-title').textContent = 'ðŸ“‘ New Template';
            document.getElementById('task-title').value = '';
            document.getElementById('task-description').value = '';
            document.getElementById('task-status').value = 'backlog';
            document.getElementById('task-priority').value = 'medium';
            document.getElementById('task-project').value = 'system';
            document.getElementById('btn-delete-task').style.display = 'none';
            
            currentTaskTags = [];
            renderTagChips();
            
            document.getElementById('subtasks-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No subtasks yet</div>';
            document.getElementById('comments-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No comments yet</div>';
            
            document.getElementById('task-modal').classList.add('visible');
        }

        let isEditingTemplate = false;

        function openTemplateDetail(templateId) {
            if (!STATE.user) {
                showToast('error', 'Login to edit templates');
                return;
            }
            
            const data = STATE.data || FALLBACK_DATA;
            const template = data.tasks.find(t => t.id === templateId);
            
            if (!template) {
                showToast('error', 'Template not found');
                return;
            }
            
            currentEditingTaskId = templateId;
            isEditingTemplate = true;
            
            document.getElementById('task-modal-title').textContent = 'ðŸ“‘ Edit Template';
            document.getElementById('task-title').value = template.title;
            document.getElementById('task-description').value = template.description;
            document.getElementById('task-status').value = template.baseStatus || 'backlog';
            document.getElementById('task-priority').value = template.priority;
            document.getElementById('task-project').value = template.project;
            document.getElementById('btn-delete-task').style.display = 'block';
            
            currentTaskTags = [...(template.tags || [])];
            renderTagChips();
            
            renderSubtasks(template);
            renderComments(template);
            
            document.getElementById('task-modal').classList.add('visible');
        }

        function executeTemplate(templateId) {
            const data = STATE.data || FALLBACK_DATA;
            const template = data.tasks.find(t => t.id === templateId);
            
            if (!template) {
                showToast('error', 'Template not found');
                return;
            }
            
            // Create task from template
            const newTask = structuredClone(template);
            newTask.id = 'task_' + Date.now();
            newTask.isTemplate = false;
            newTask.status = template.baseStatus || 'backlog';
            newTask.createdAt = new Date().toISOString();
            newTask.createdFromTemplate = templateId;
            delete newTask.executionCount;
            delete newTask.baseStatus;
            
            // Clear subtask completion status
            if (newTask.subtasks) {
                newTask.subtasks = newTask.subtasks.map(s => ({
                    ...s,
                    id: 'sub_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    done: false
                }));
            }
            
            STATE.data.tasks.push(newTask);
            
            // Increment execution counter
            template.executionCount = (template.executionCount || 0) + 1;
            
            renderTemplates();
            renderTasks();
            autoSave(`Execute template "${template.title}"`);
            showToast('success', `Created task from template: ${newTask.title}`);
        }

        // Task 8: Template-Duplikat
        function duplicateTemplate(templateId) {
            const data = STATE.data || FALLBACK_DATA;
            const template = data.tasks.find(t => t.id === templateId);
            
            if (!template) {
                showToast('error', 'Template not found');
                return;
            }
            
            // Deep copy
            const newTemplate = structuredClone(template);
            newTemplate.id = 'template_' + Date.now();
            newTemplate.createdAt = new Date().toISOString();
            newTemplate.executionCount = 0;
            
            // Generate suffix
            const baseName = template.title.replace(/ \(Kopie( \d+)?\)$/, '');
            const existingCopies = data.tasks.filter(t => 
                t.isTemplate && 
                (t.title === baseName + ' (Kopie)' || t.title.match(new RegExp(`^${baseName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')} \\(Kopie \\d+\\)$`)))
            );
            
            if (existingCopies.length === 0) {
                newTemplate.title = baseName + ' (Kopie)';
            } else {
                newTemplate.title = baseName + ' (Kopie ' + (existingCopies.length + 1) + ')';
            }
            
            // Reset subtask IDs
            if (newTemplate.subtasks) {
                newTemplate.subtasks = newTemplate.subtasks.map(s => ({
                    ...s,
                    id: 'sub_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
                }));
            }
            
            STATE.data.tasks.push(newTemplate);
            renderTemplates();
            autoSave(`Duplicate template "${template.title}"`);
            
            // Open edit modal with focus on title
            setTimeout(() => {
                openTemplateDetail(newTemplate.id);
                setTimeout(() => {
                    const titleInput = document.getElementById('task-title');
                    if (titleInput) {
                        titleInput.focus();
                        titleInput.select();
                    }
                }, 100);
            }, 200);
        }

        // Template Done Confirmation Dialog
        function showTemplateExecutionDialog(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.createdFromTemplate) {
                quickMoveTask(taskId, 'done');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'template-execution-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2 class="modal-title">âœ… Task Completed</h2>
                        <button class="modal-close" onclick="closeTemplateDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 1rem;">This task was created from a template. What would you like to do?</p>
                    </div>
                    <div class="modal-footer" style="flex-direction: column; gap: 0.5rem;">
                        <button class="btn btn-primary" style="width: 100%;" onclick="executeOnlyFromDialog('${taskId}')">
                            â–¶ Just Execute (stays available)
                        </button>
                        <button class="btn btn-secondary" style="width: 100%;" onclick="archiveFromDialog('${taskId}')">
                            ðŸ“¦ Archive Task
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }

        function closeTemplateDialog() {
            const dialog = document.getElementById('template-execution-dialog');
            if (dialog) dialog.remove();
        }

        function executeOnlyFromDialog(taskId) {
            closeTemplateDialog();
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                // Move to done but don't archive - will auto-return
                task.status = 'done';
                task.completedAt = new Date().toISOString();
                
                // Auto-return to backlog after marking done
                setTimeout(() => {
                    if (task.status === 'done' && !task.archived) {
                        task.status = task.baseStatus || 'backlog';
                        delete task.completedAt;
                        // Reset subtasks
                        if (task.subtasks) {
                            task.subtasks.forEach(s => s.done = false);
                        }
                        renderTasks();
                        showToast('success', `Task "${task.title}" returned to backlog`);
                    }
                }, 2000);
                
                renderTasks();
                autoSave(`Complete "${task.title}" (auto-return)`);
            }
        }

        function archiveFromDialog(taskId) {
            closeTemplateDialog();
            quickMoveTask(taskId, 'done');
        }

        // === SCHEDULED TASKS FUNCTIONS (Task 7) ===
        function renderScheduledTasks() {
            const container = document.getElementById('tasks-scheduled');
            const countEl = document.getElementById('count-scheduled');
            const data = STATE.data || FALLBACK_DATA;
            const scheduled = data.tasks.filter(t => t.scheduledAt && t.status === 'scheduled');
            
            countEl.textContent = scheduled.length;
            
            if (scheduled.length === 0) {
                container.innerHTML = '<div class="empty-state">No scheduled tasks</div>';
                return;
            }
            
            // Sort by scheduledAt
            scheduled.sort((a, b) => new Date(a.scheduledAt) - new Date(b.scheduledAt));
            
            container.innerHTML = scheduled.map(task => {
                const scheduledDate = new Date(task.scheduledAt);
                const now = new Date();
                const isOverdue = scheduledDate < now;
                const countdown = formatScheduledCountdown(scheduledDate);
                
                return `
                    <div class="scheduled-card ${isOverdue ? 'overdue' : ''}" data-task-id="${task.id}" onclick="openTaskDetail('${task.id}')">
                        <div class="scheduled-name">${task.title}</div>
                        <div class="scheduled-time">
                            <span class="countdown ${isOverdue ? 'overdue' : ''}">
                                ${isOverdue ? 'âš ï¸ Overdue' : 'â° ' + countdown}
                            </span>
                        </div>
                        <div class="task-description">${task.description || ''}</div>
                    </div>
                `;
            }).join('');
            
            // Check for overdue tasks
            checkScheduledTasks();
        }

        function formatScheduledCountdown(date) {
            const now = new Date();
            const diff = date - now;
            
            if (diff < 0) return 'Overdue';
            
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (days > 0) return `in ${days}d ${hours % 24}h`;
            if (hours > 0) return `in ${hours}h ${minutes % 60}m`;
            return `in ${minutes}m`;
        }

        function checkScheduledTasks() {
            const data = STATE.data || FALLBACK_DATA;
            const scheduled = data.tasks.filter(t => t.scheduledAt && t.status === 'scheduled');
            const now = new Date();
            
            scheduled.forEach(task => {
                const scheduledDate = new Date(task.scheduledAt);
                if (scheduledDate <= now) {
                    // Auto-execute overdue task
                    executeScheduledTask(task.id);
                }
            });
        }

        function executeScheduledTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            task.status = 'in_progress';
            delete task.scheduledAt;
            
            renderScheduledTasks();
            renderTasks();
            autoSave(`Auto-execute scheduled task "${task.title}"`);
            showToast('success', `Scheduled task "${task.title}" is now in progress!`);
        }

        function openScheduledTaskModal() {
            if (!STATE.user) {
                showToast('error', 'Login to schedule tasks');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'scheduled-task-dialog';
            
            const now = new Date();
            const defaultDate = new Date(now.getTime() + 24 * 60 * 60 * 1000); // Tomorrow
            const dateStr = defaultDate.toISOString().slice(0, 16);
            
            dialog.innerHTML = `
                <div class="modal" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2 class="modal-title">ðŸ“… Schedule Task</h2>
                        <button class="modal-close" onclick="closeScheduledTaskDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Title</label>
                            <input type="text" class="form-input" id="scheduled-title" placeholder="Task title">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Description</label>
                            <textarea class="form-input" id="scheduled-description" rows="2" placeholder="Task description"></textarea>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Scheduled For</label>
                            <input type="datetime-local" class="form-input" id="scheduled-datetime" value="${dateStr}">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Priority</label>
                            <select class="form-input" id="scheduled-priority">
                                <option value="low">Low</option>
                                <option value="medium" selected>Medium</option>
                                <option value="high">High</option>
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeScheduledTaskDialog()">Cancel</button>
                        <button class="btn btn-primary" onclick="saveScheduledTask()">Schedule Task</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            document.getElementById('scheduled-title').focus();
        }

        function closeScheduledTaskDialog() {
            const dialog = document.getElementById('scheduled-task-dialog');
            if (dialog) dialog.remove();
        }

        function saveScheduledTask() {
            const title = document.getElementById('scheduled-title').value.trim();
            const description = document.getElementById('scheduled-description').value.trim();
            const datetime = document.getElementById('scheduled-datetime').value;
            const priority = document.getElementById('scheduled-priority').value;
            
            if (!title) {
                showToast('error', 'Title is required');
                return;
            }
            
            if (!datetime) {
                showToast('error', 'Please select a date and time');
                return;
            }
            
            const scheduledAt = new Date(datetime).toISOString();
            
            const newTask = {
                id: 'task_' + Date.now(),
                title,
                description,
                status: 'scheduled',
                scheduledAt,
                priority,
                project: 'system',
                tags: ['scheduled'],
                subtasks: [],
                createdAt: new Date().toISOString()
            };
            
            STATE.data.tasks.push(newTask);
            closeScheduledTaskDialog();
            renderScheduledTasks();
            autoSave(`Schedule task "${title}"`);
            showToast('success', `Task scheduled for ${new Date(scheduledAt).toLocaleString()}`);
        }

        // Check scheduled tasks every minute
        setInterval(() => {
            if (STATE.data) checkScheduledTasks();
        }, 60000);
        
        // Update scheduled task countdowns every 30 seconds
        setInterval(() => {
            if (STATE.data) renderScheduledTasks();
        }, 30000);
        
        // Update processing task timers every 30 seconds (for elapsed time display)
        setInterval(() => {
            if (STATE.data) {
                const processingTasks = STATE.data.tasks.filter(t => 
                    (t.processingStartedAt || t.processing) && t.status === 'in_progress'
                );
                if (processingTasks.length > 0) {
                    renderTasks();
                }
            }
        }, 30000);

        // === TASK 1: CRON DRAG & DROP ===
        let draggedCronId = null;
        
        function handleCronDragStart(event, cronId) {
            draggedCronId = cronId;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', 'cron:' + cronId);
        }
        
        function handleCronDragEnd(event) {
            event.target.classList.remove('dragging');
            draggedCronId = null;
            document.querySelectorAll('.column-tasks').forEach(col => {
                col.classList.remove('drag-over');
            });
        }
        
        function handleCronDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }
        
        function handleCronDragLeave(event) {
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX;
            const y = event.clientY;
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                event.currentTarget.classList.remove('drag-over');
            }
        }
        
        function handleCronDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            // Crons dropped back on Recurring - do nothing
        }
        
        // Extended handleDrop for Cron drops
        const originalHandleDrop = handleDrop;
        handleDrop = function(event, newStatus) {
            event.preventDefault();
            const container = event.currentTarget;
            container.classList.remove('drag-over');
            
            const data = event.dataTransfer.getData('text/plain');
            
            // Check if it's a cron being dropped
            if (data.startsWith('cron:')) {
                const cronId = data.replace('cron:', '');
                const cron = STATE.crons?.find(c => c.id === cronId);
                
                if (!cron) return;
                
                if (newStatus === 'in_progress') {
                    // Execute cron via Gateway API
                    executeCronJob(cronId);
                } else if (newStatus === 'done') {
                    // Disable the cron
                    disableCronJob(cronId);
                } else {
                    showToast('info', 'Drop on "In Progress" to execute, "Done" to disable');
                }
                return;
            }
            
            // Regular task drop
            document.querySelectorAll('.task-card').forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });

            if (!draggedTaskId || !STATE.user) return;

            const task = STATE.data.tasks.find(t => t.id === draggedTaskId);
            if (!task) return;

            const oldStatus = task.status;
            const statusChanged = task.status !== newStatus;
            
            // Check if this is a template-created task being moved to Done
            if (newStatus === 'done' && task.createdFromTemplate) {
                showTemplateExecutionDialog(draggedTaskId);
                draggedTaskId = null;
                return;
            }
            
            task.status = newStatus;

            // Set completedAt when moving to done
            if (newStatus === 'done') {
                task.completedAt = new Date().toISOString();
            } else if (oldStatus === 'done') {
                delete task.completedAt;
            }

            // Calculate new sortOrder based on drop position
            const priorityOrder = { high: 0, medium: 1, low: 2 };
            let tasksInColumn = STATE.data.tasks
                .filter(t => t.status === newStatus && t.id !== task.id)
                .sort((a, b) => {
                    const prioA = priorityOrder[a.priority] ?? 1;
                    const prioB = priorityOrder[b.priority] ?? 1;
                    if (prioA !== prioB) return prioA - prioB;
                    return (a.sortOrder ?? 999999) - (b.sortOrder ?? 999999);
                });

            // Find insert position
            let insertIdx = tasksInColumn.length;
            if (dropTargetInfo?.insertBeforeId) {
                const targetIdx = tasksInColumn.findIndex(t => t.id === dropTargetInfo.insertBeforeId);
                if (targetIdx >= 0) insertIdx = targetIdx;
            }

            // Insert task at position
            tasksInColumn.splice(insertIdx, 0, task);

            // Recalculate sortOrder for all tasks in this column
            let currentPriority = null;
            let orderCounter = 0;
            tasksInColumn.forEach(t => {
                if (t.priority !== currentPriority) {
                    currentPriority = t.priority;
                    orderCounter = 0;
                }
                t.sortOrder = orderCounter++;
            });

            STATE.data.lastUpdated = new Date().toISOString();

            if (statusChanged) {
                STATE.data.activities = STATE.data.activities || [];
                STATE.data.activities.unshift({
                    type: 'moved',
                    actor: STATE.user?.login || 'User',
                    task: task.title,
                    from: oldStatus,
                    to: newStatus,
                    time: 'just now'
                });
                renderActivity();
            }

            renderTasksSmooth(oldStatus, newStatus, task.id);

            const action = statusChanged
                ? `Move "${task.title}" â†’ ${newStatus}`
                : `Reorder "${task.title}"`;
            autoSave(action);

            dropTargetInfo = null;
            lastDropTargetInfo = null;
        };
        
        async function executeCronJob(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const gatewayUrl = getGatewayUrl();
            
            if (!gatewayUrl) {
                // No gateway available - show CLI command
                showToast('info', `ðŸš€ To execute "${cron.name}":`);
                setTimeout(() => {
                    showToast('info', `Run: clawdbot cron run ${cronId}`, 8000);
                }, 500);
                // Copy command to clipboard
                navigator.clipboard?.writeText(`clawdbot cron run ${cronId}`);
                return;
            }
            
            showToast('info', `ðŸš€ Executing "${cron.name}"...`);
            
            try {
                // Call Gateway API to execute cron
                const response = await fetch(gatewayUrl + '/api/crons/' + cronId + '/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    showToast('success', `âœ“ Cron "${cron.name}" started`);
                    // Start polling for status
                    pollCronStatus(cronId);
                } else {
                    showToast('error', `Failed to execute cron`);
                }
            } catch (e) {
                // Fallback: Show CLI command
                showToast('info', `Gateway not reachable. Run: clawdbot cron run ${cronId}`, 8000);
                navigator.clipboard?.writeText(`clawdbot cron run ${cronId}`);
            }
        }
        
        let cronPollingIntervals = {};
        
        function pollCronStatus(cronId) {
            // Poll every 2 seconds
            if (cronPollingIntervals[cronId]) {
                clearInterval(cronPollingIntervals[cronId]);
            }
            
            cronPollingIntervals[cronId] = setInterval(async () => {
                try {
                    await loadCronsFromGitHub();
                    const cron = STATE.crons?.find(c => c.id === cronId);
                    
                    if (cron && cron.lastStatus === 'ok') {
                        clearInterval(cronPollingIntervals[cronId]);
                        delete cronPollingIntervals[cronId];
                        showToast('success', `âœ… Cron "${cron.name}" completed`);
                        renderCrons();
                    }
                } catch (e) {
                    console.log('Polling error:', e);
                }
            }, 2000);
            
            // Stop polling after 5 minutes
            setTimeout(() => {
                if (cronPollingIntervals[cronId]) {
                    clearInterval(cronPollingIntervals[cronId]);
                    delete cronPollingIntervals[cronId];
                }
            }, 5 * 60 * 1000);
        }
        
        async function disableCronJob(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const gatewayUrl = getGatewayUrl();
            if (!gatewayUrl) {
                showToast('info', `Run: clawdbot cron update ${cronId} --disabled`, 8000);
                navigator.clipboard?.writeText(`clawdbot cron update ${cronId} --disabled`);
                return;
            }
            
            try {
                const response = await fetch(gatewayUrl + '/api/crons/' + cronId, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: false })
                });
                
                if (response.ok) {
                    cron.enabled = false;
                    renderCrons();
                    showToast('success', `Disabled cron "${cron.name}"`);
                } else {
                    showToast('error', 'Failed to disable cron');
                }
            } catch (e) {
                showToast('info', `Run: clawdbot cron update ${cronId} --disabled`, 8000);
            }
        }

        // === TASK 2: CRON EDITOR ===
        function openCronDetail(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) {
                showToast('error', 'Cron not found');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'cron-editor-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 550px;">
                    <div class="modal-header">
                        <h2 class="modal-title">ðŸ”„ Edit Cron Job</h2>
                        <button class="modal-close" onclick="closeCronEditor()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Name</label>
                            <input type="text" class="form-input" id="cron-name" value="${escapeHtml(cron.name)}">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Prompt / Command</label>
                            <textarea class="form-input" id="cron-prompt" rows="4" placeholder="What should this cron do?">${escapeHtml(cron.prompt || '')}</textarea>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Schedule (Cron Expression)</label>
                            <input type="text" class="form-input" id="cron-schedule" value="${cron.schedule}" placeholder="0 8 * * *">
                            <div class="form-hint" id="cron-schedule-hint">
                                Human readable: <strong>${cron.scheduleHuman || 'Unknown'}</strong>
                            </div>
                            <div id="cron-validation-error" style="color: var(--accent-red); font-size: 0.8rem; margin-top: 0.25rem; display: none;"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Timezone</label>
                            <select class="form-input" id="cron-timezone">
                                <option value="Europe/Berlin" ${cron.timezone === 'Europe/Berlin' ? 'selected' : ''}>Europe/Berlin</option>
                                <option value="UTC" ${cron.timezone === 'UTC' ? 'selected' : ''}>UTC</option>
                                <option value="America/New_York" ${cron.timezone === 'America/New_York' ? 'selected' : ''}>America/New_York</option>
                                <option value="America/Los_Angeles" ${cron.timezone === 'America/Los_Angeles' ? 'selected' : ''}>America/Los_Angeles</option>
                                <option value="Asia/Tokyo" ${cron.timezone === 'Asia/Tokyo' ? 'selected' : ''}>Asia/Tokyo</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                <input type="checkbox" id="cron-enabled" ${cron.enabled ? 'checked' : ''}>
                                <span>Enabled</span>
                            </label>
                        </div>
                        <div class="form-group" style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px;">
                            <label class="form-label" style="margin-bottom: 0.5rem;">ðŸ“… Next 5 Runs</label>
                            <div id="cron-next-runs" style="font-size: 0.85rem; color: var(--text-secondary);">
                                ${generateNextRuns(cron.schedule, cron.timezone)}
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" style="margin-right: auto;" onclick="convertCronToTask('${cronId}')">ðŸ“‹ As Task</button>
                        <button class="btn btn-secondary" onclick="closeCronEditor()">Cancel</button>
                        <button class="btn btn-primary" onclick="saveCronChanges('${cronId}')">Save Changes</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            
            // Add schedule validation on input
            document.getElementById('cron-schedule').addEventListener('input', function() {
                validateCronSchedule(this.value);
            });
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            return text.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;');
        }
        
        function validateCronSchedule(schedule) {
            const errorEl = document.getElementById('cron-validation-error');
            const hintEl = document.getElementById('cron-schedule-hint');
            const nextRunsEl = document.getElementById('cron-next-runs');
            
            // Simple cron validation (5 fields)
            const parts = schedule.trim().split(/\s+/);
            if (parts.length !== 5) {
                errorEl.textContent = 'Cron expression must have 5 fields (minute hour day month weekday)';
                errorEl.style.display = 'block';
                return false;
            }
            
            // Validate each field
            const ranges = [
                { min: 0, max: 59, name: 'minute' },
                { min: 0, max: 23, name: 'hour' },
                { min: 1, max: 31, name: 'day' },
                { min: 1, max: 12, name: 'month' },
                { min: 0, max: 7, name: 'weekday' }
            ];
            
            for (let i = 0; i < 5; i++) {
                if (!isValidCronField(parts[i], ranges[i])) {
                    errorEl.textContent = `Invalid ${ranges[i].name} field: ${parts[i]}`;
                    errorEl.style.display = 'block';
                    return false;
                }
            }
            
            errorEl.style.display = 'none';
            const humanReadable = cronToHuman(schedule);
            hintEl.innerHTML = `Human readable: <strong>${humanReadable}</strong>`;
            nextRunsEl.innerHTML = generateNextRuns(schedule, document.getElementById('cron-timezone')?.value || 'Europe/Berlin');
            return true;
        }
        
        function isValidCronField(field, range) {
            if (field === '*') return true;
            if (field.includes('/')) {
                const [base, step] = field.split('/');
                if (base !== '*' && !isValidCronField(base, range)) return false;
                const stepNum = parseInt(step);
                return !isNaN(stepNum) && stepNum > 0;
            }
            if (field.includes('-')) {
                const [start, end] = field.split('-').map(Number);
                return !isNaN(start) && !isNaN(end) && start >= range.min && end <= range.max && start <= end;
            }
            if (field.includes(',')) {
                return field.split(',').every(f => isValidCronField(f.trim(), range));
            }
            const num = parseInt(field);
            return !isNaN(num) && num >= range.min && num <= range.max;
        }
        
        function cronToHuman(schedule) {
            const parts = schedule.trim().split(/\s+/);
            if (parts.length !== 5) return schedule;
            
            const [minute, hour, day, month, weekday] = parts;
            
            // Simple patterns
            if (minute !== '*' && hour !== '*' && day === '*' && month === '*' && weekday === '*') {
                return `Daily at ${hour.padStart(2, '0')}:${minute.padStart(2, '0')}`;
            }
            if (minute !== '*' && hour !== '*' && day === '*' && month === '*' && weekday !== '*') {
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const dayName = days[parseInt(weekday)] || weekday;
                return `${dayName} at ${hour.padStart(2, '0')}:${minute.padStart(2, '0')}`;
            }
            if (minute === '0' && hour === '*' && day === '*' && month === '*' && weekday === '*') {
                return 'Every hour';
            }
            if (minute.includes('/')) {
                const interval = minute.split('/')[1];
                return `Every ${interval} minutes`;
            }
            
            return schedule;
        }
        
        function generateNextRuns(schedule, timezone) {
            try {
                // Simple next run calculation (approximate)
                const runs = [];
                const now = new Date();
                let checkDate = new Date(now);
                
                const parts = schedule.trim().split(/\s+/);
                if (parts.length !== 5) return 'Invalid schedule';
                
                const [cronMin, cronHour, cronDay, cronMonth, cronWeekday] = parts;
                
                for (let i = 0; i < 100 && runs.length < 5; i++) {
                    checkDate = new Date(checkDate.getTime() + (i === 0 ? 60000 : 60000));
                    
                    const min = checkDate.getMinutes();
                    const hour = checkDate.getHours();
                    const day = checkDate.getDate();
                    const month = checkDate.getMonth() + 1;
                    const weekday = checkDate.getDay();
                    
                    if (matchesCronField(cronMin, min) &&
                        matchesCronField(cronHour, hour) &&
                        matchesCronField(cronDay, day) &&
                        matchesCronField(cronMonth, month) &&
                        matchesCronField(cronWeekday, weekday)) {
                        runs.push(checkDate.toLocaleString('de-DE', { 
                            weekday: 'short', 
                            day: '2-digit', 
                            month: '2-digit', 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        }));
                        // Skip to next minute
                        checkDate = new Date(checkDate.getTime() + 60000);
                    }
                    
                    // Skip forward more aggressively for daily/weekly jobs
                    if (cronMin !== '*' && cronHour !== '*') {
                        checkDate = new Date(checkDate.getTime() + 3600000); // Skip 1 hour
                    }
                }
                
                return runs.length > 0 ? runs.map(r => `â€¢ ${r}`).join('<br>') : 'Could not calculate next runs';
            } catch (e) {
                return 'Error calculating runs';
            }
        }
        
        function matchesCronField(field, value) {
            if (field === '*') return true;
            if (field.includes('/')) {
                const [base, step] = field.split('/');
                const stepNum = parseInt(step);
                if (base === '*') return value % stepNum === 0;
                return false; // Simplified
            }
            if (field.includes(',')) {
                return field.split(',').some(f => matchesCronField(f.trim(), value));
            }
            if (field.includes('-')) {
                const [start, end] = field.split('-').map(Number);
                return value >= start && value <= end;
            }
            return parseInt(field) === value;
        }
        
        function closeCronEditor() {
            const dialog = document.getElementById('cron-editor-dialog');
            if (dialog) dialog.remove();
        }
        
        async function saveCronChanges(cronId) {
            const name = document.getElementById('cron-name').value.trim();
            const prompt = document.getElementById('cron-prompt').value.trim();
            const schedule = document.getElementById('cron-schedule').value.trim();
            const timezone = document.getElementById('cron-timezone').value;
            const enabled = document.getElementById('cron-enabled').checked;
            
            if (!name) {
                showToast('error', 'Name is required');
                return;
            }
            
            if (!validateCronSchedule(schedule)) {
                showToast('error', 'Invalid cron schedule');
                return;
            }
            
            const gatewayUrl = getGatewayUrl();
            if (!gatewayUrl) {
                // Save locally and show CLI command
                const cron = STATE.crons?.find(c => c.id === cronId);
                if (cron) {
                    cron.name = name;
                    cron.prompt = prompt;
                    cron.schedule = schedule;
                    cron.scheduleHuman = cronToHuman(schedule);
                    cron.timezone = timezone;
                    cron.enabled = enabled;
                }
                closeCronEditor();
                renderCrons();
                showToast('info', 'Gateway not available. Changes saved locally only.');
                return;
            }
            
            try {
                const response = await fetch(gatewayUrl + '/api/crons/' + cronId, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, prompt, schedule, timezone, enabled })
                });
                
                if (response.ok) {
                    const cron = STATE.crons?.find(c => c.id === cronId);
                    if (cron) {
                        cron.name = name;
                        cron.prompt = prompt;
                        cron.schedule = schedule;
                        cron.scheduleHuman = cronToHuman(schedule);
                        cron.timezone = timezone;
                        cron.enabled = enabled;
                    }
                    closeCronEditor();
                    renderCrons();
                    showToast('success', `Cron "${name}" updated`);
                } else {
                    showToast('error', 'Failed to save cron');
                }
            } catch (e) {
                showToast('info', 'Gateway not available. Changes saved locally only.');
                const cron = STATE.crons?.find(c => c.id === cronId);
                if (cron) {
                    cron.name = name;
                    cron.prompt = prompt;
                    cron.schedule = schedule;
                    cron.scheduleHuman = cronToHuman(schedule);
                    cron.timezone = timezone;
                    cron.enabled = enabled;
                }
                closeCronEditor();
                renderCrons();
            }
        }

        // === TASK 3: TASK â†’ CRON ===
        function openTaskToCronWizard(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'task-to-cron-wizard';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2 class="modal-title">â° Convert to Cron</h2>
                        <button class="modal-close" onclick="closeTaskToCronWizard()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="steps" style="margin-bottom: 1rem;">
                            <div class="step">
                                <span class="step-number">1</span>
                                <div class="step-content">
                                    <div class="step-title">Choose Schedule Type</div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="wizard-step-1">
                            <div style="display: grid; gap: 0.5rem;">
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('daily')">
                                    ðŸ“… Daily
                                </button>
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('weekly')">
                                    ðŸ“† Weekly
                                </button>
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('monthly')">
                                    ðŸ—“ï¸ Monthly
                                </button>
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('custom')">
                                    âš™ï¸ Custom Cron Expression
                                </button>
                            </div>
                        </div>
                        
                        <div id="wizard-step-2" style="display: none;">
                            <div class="form-group">
                                <label class="form-label">Time</label>
                                <input type="time" class="form-input" id="wizard-time" value="08:00">
                            </div>
                            <div class="form-group" id="wizard-weekday-group" style="display: none;">
                                <label class="form-label">Day of Week</label>
                                <select class="form-input" id="wizard-weekday">
                                    <option value="1">Monday</option>
                                    <option value="2">Tuesday</option>
                                    <option value="3">Wednesday</option>
                                    <option value="4">Thursday</option>
                                    <option value="5">Friday</option>
                                    <option value="6">Saturday</option>
                                    <option value="0">Sunday</option>
                                </select>
                            </div>
                            <div class="form-group" id="wizard-monthday-group" style="display: none;">
                                <label class="form-label">Day of Month</label>
                                <input type="number" class="form-input" id="wizard-monthday" min="1" max="31" value="1">
                            </div>
                            <div class="form-group" id="wizard-custom-group" style="display: none;">
                                <label class="form-label">Cron Expression</label>
                                <input type="text" class="form-input" id="wizard-custom-cron" placeholder="0 8 * * *">
                            </div>
                        </div>
                        
                        <div id="wizard-step-3" style="display: none;">
                            <div class="form-group">
                                <label class="form-label">Cron Name</label>
                                <input type="text" class="form-input" id="cron-wizard-title" value="${task.title}">
                            </div>
                            <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px;">
                                <strong>Summary:</strong>
                                <div id="wizard-summary" style="margin-top: 0.5rem; color: var(--text-secondary);"></div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" id="wizard-back" onclick="wizardBack()" style="display: none;">Back</button>
                        <button class="btn btn-secondary" onclick="closeTaskToCronWizard()">Cancel</button>
                        <button class="btn btn-primary" id="wizard-next" onclick="wizardNext('${taskId}')" style="display: none;">Next</button>
                        <button class="btn btn-primary" id="wizard-create" onclick="createCronFromTask('${taskId}')" style="display: none;">Create Cron</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            
            window.wizardState = { step: 1, type: null, taskId };
        }
        
        function setScheduleType(type) {
            window.wizardState.type = type;
            document.getElementById('wizard-step-1').style.display = 'none';
            document.getElementById('wizard-step-2').style.display = 'block';
            document.getElementById('wizard-back').style.display = 'inline-flex';
            document.getElementById('wizard-next').style.display = 'inline-flex';
            
            // Show relevant fields
            document.getElementById('wizard-weekday-group').style.display = type === 'weekly' ? 'block' : 'none';
            document.getElementById('wizard-monthday-group').style.display = type === 'monthly' ? 'block' : 'none';
            document.getElementById('wizard-custom-group').style.display = type === 'custom' ? 'block' : 'none';
            
            window.wizardState.step = 2;
        }
        
        function wizardBack() {
            if (window.wizardState.step === 2) {
                document.getElementById('wizard-step-2').style.display = 'none';
                document.getElementById('wizard-step-1').style.display = 'block';
                document.getElementById('wizard-back').style.display = 'none';
                document.getElementById('wizard-next').style.display = 'none';
                window.wizardState.step = 1;
            } else if (window.wizardState.step === 3) {
                document.getElementById('wizard-step-3').style.display = 'none';
                document.getElementById('wizard-step-2').style.display = 'block';
                document.getElementById('wizard-next').style.display = 'inline-flex';
                document.getElementById('wizard-create').style.display = 'none';
                window.wizardState.step = 2;
            }
        }
        
        function wizardNext(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            const type = window.wizardState.type;
            const time = document.getElementById('wizard-time').value;
            const [hour, minute] = time.split(':');
            
            let schedule;
            let scheduleDesc;
            
            if (type === 'daily') {
                schedule = `${minute} ${hour} * * *`;
                scheduleDesc = `Daily at ${time}`;
            } else if (type === 'weekly') {
                const weekday = document.getElementById('wizard-weekday').value;
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                schedule = `${minute} ${hour} * * ${weekday}`;
                scheduleDesc = `Every ${dayNames[parseInt(weekday)]} at ${time}`;
            } else if (type === 'monthly') {
                const monthday = document.getElementById('wizard-monthday').value;
                schedule = `${minute} ${hour} ${monthday} * *`;
                scheduleDesc = `Monthly on day ${monthday} at ${time}`;
            } else {
                schedule = document.getElementById('wizard-custom-cron').value;
                scheduleDesc = schedule;
            }
            
            window.wizardState.schedule = schedule;
            window.wizardState.scheduleDesc = scheduleDesc;
            
            // Build prompt from task
            let prompt = task.description || task.title;
            if (task.subtasks && task.subtasks.length > 0) {
                prompt += '\n\nSubtasks:\n' + task.subtasks.map(s => `- ${s.title}`).join('\n');
            }
            window.wizardState.prompt = prompt;
            
            // Show summary
            document.getElementById('wizard-step-2').style.display = 'none';
            document.getElementById('wizard-step-3').style.display = 'block';
            document.getElementById('wizard-next').style.display = 'none';
            document.getElementById('wizard-create').style.display = 'inline-flex';
            
            document.getElementById('wizard-summary').innerHTML = `
                <strong>Name:</strong> ${task.title}<br>
                <strong>Schedule:</strong> ${scheduleDesc}<br>
                <strong>Cron:</strong> <code>${schedule}</code><br>
                <strong>Original task will be archived.</strong>
            `;
            
            window.wizardState.step = 3;
        }
        
        async function createCronFromTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            // Read current values from wizard inputs (not stored state)
            const titleInput = document.getElementById('cron-wizard-title');
            const cronTitle = titleInput ? titleInput.value.trim() : task.title;
            const { schedule, scheduleDesc, prompt } = window.wizardState;
            const gatewayUrl = getGatewayUrl();
            
            // Helper to create cron locally and save to GitHub
            async function createLocalCron() {
                const newCron = {
                    id: crypto.randomUUID ? crypto.randomUUID() : 'cron_' + Date.now(),
                    name: cronTitle,
                    prompt: prompt,
                    schedule: schedule,
                    scheduleHuman: scheduleDesc,
                    timezone: 'Europe/Berlin',
                    enabled: true,
                    pending: true, // Mark as pending - needs Gateway sync
                    createdAt: new Date().toISOString()
                };
                
                STATE.crons = STATE.crons || [];
                STATE.crons.push(newCron);
                
                // Archive original task
                task.archived = true;
                task.archivedAt = new Date().toISOString();
                task.archivedReason = 'Converted to cron: ' + newCron.id;
                
                // Save crons to GitHub
                const cronsSaved = await saveCronsToGitHub(`Add cron "${cronTitle}" (pending Gateway sync)`);
                
                closeTaskToCronWizard();
                renderCrons();
                renderTasks();
                autoSave(`Convert task "${task.title}" to cron`);
                
                if (cronsSaved) {
                    showToast('success', `âœ“ Cron "${cronTitle}" saved (will activate on next sync)`);
                } else {
                    showToast('warning', `Cron created locally but failed to save to GitHub`);
                }
                return true;
            }
            
            if (!gatewayUrl) {
                // No Gateway available - save locally to GitHub
                await createLocalCron();
                return;
            }
            
            try {
                const response = await fetch(gatewayUrl + '/api/crons', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: cronTitle,
                        prompt: prompt,
                        schedule: schedule,
                        scheduleHuman: scheduleDesc,
                        timezone: 'Europe/Berlin',
                        enabled: true
                    })
                });
                
                if (response.ok) {
                    const newCron = await response.json();
                    STATE.crons = STATE.crons || [];
                    STATE.crons.push(newCron);
                    
                    // Archive original task
                    task.archived = true;
                    task.archivedAt = new Date().toISOString();
                    task.archivedReason = 'Converted to cron: ' + newCron.id;
                    
                    closeTaskToCronWizard();
                    renderCrons();
                    renderTasks();
                    autoSave(`Convert task "${task.title}" to cron`);
                    showToast('success', `Created cron "${cronTitle}"`);
                } else {
                    showToast('error', 'Failed to create cron via Gateway');
                }
            } catch (e) {
                // Gateway not reachable - fallback to local save
                console.log('Gateway not reachable, saving locally:', e);
                await createLocalCron();
            }
        }
        
        function closeTaskToCronWizard() {
            const dialog = document.getElementById('task-to-cron-wizard');
            if (dialog) dialog.remove();
            delete window.wizardState;
        }

        // === TASK 4: CRON â†’ TASK ===
        function convertCronToTask(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'cron-to-task-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2 class="modal-title">ðŸ“‹ Convert to Task</h2>
                        <button class="modal-close" onclick="closeCronToTaskDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 1rem;">Create a task from cron "${cron.name}"?</p>
                        <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <strong>Task will include:</strong>
                            <div style="color: var(--text-secondary); margin-top: 0.5rem;">
                                Schedule: ${cron.scheduleHuman || cron.schedule}<br>
                                ${cron.prompt ? `Prompt: ${cron.prompt.substring(0, 100)}${cron.prompt.length > 100 ? '...' : ''}` : ''}
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">What to do with the cron?</label>
                            <select class="form-input" id="cron-action-select">
                                <option value="disable">Disable cron</option>
                                <option value="delete">Delete cron</option>
                                <option value="keep">Keep cron active</option>
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeCronToTaskDialog()">Cancel</button>
                        <button class="btn btn-primary" onclick="executeConvertCronToTask('${cronId}')">Create Task</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }
        
        function closeCronToTaskDialog() {
            const dialog = document.getElementById('cron-to-task-dialog');
            if (dialog) dialog.remove();
        }
        
        async function executeConvertCronToTask(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const action = document.getElementById('cron-action-select').value;
            
            // Create task
            const newTask = {
                id: 'task_' + Date.now(),
                title: cron.name,
                description: `Schedule: ${cron.scheduleHuman || cron.schedule}\n\n${cron.prompt || ''}`,
                status: 'backlog',
                project: 'system',
                tags: ['from-cron'],
                subtasks: [],
                priority: 'medium',
                createdAt: new Date().toISOString(),
                createdFromCron: cronId
            };
            
            STATE.data.tasks.push(newTask);
            
            // Handle cron action
            if (action === 'disable') {
                await disableCronJob(cronId);
            } else if (action === 'delete') {
                const gatewayUrl = getGatewayUrl();
                if (gatewayUrl) {
                    try {
                        await fetch(gatewayUrl + '/api/crons/' + cronId, { method: 'DELETE' });
                        STATE.crons = STATE.crons.filter(c => c.id !== cronId);
                    } catch (e) {
                        console.log('Could not delete cron via API');
                        showToast('info', `Run: clawdbot cron remove ${cronId}`, 8000);
                    }
                } else {
                    showToast('info', `Run: clawdbot cron remove ${cronId}`, 8000);
                    navigator.clipboard?.writeText(`clawdbot cron remove ${cronId}`);
                }
            }
            
            closeCronToTaskDialog();
            closeCronEditor();
            renderCrons();
            renderTasks();
            autoSave(`Create task from cron "${cron.name}"`);
            showToast('success', `Created task "${cron.name}"`);
        }

        // === COLLABORATORS / PEOPLE ===
        let collaboratorsLoaded = false;

        async function loadCollaborators() {
            if (collaboratorsLoaded) return;

            const container = document.getElementById('collaborators-container');
            const statsContainer = document.getElementById('people-stats');

            // Show loading
            container.innerHTML = `
                <div class="people-loading">
                    <div class="spinner"></div>
                    <p>Loading collaborators...</p>
                </div>
            `;

            const token = STATE.token || localStorage.getItem('github_token');

            if (!token) {
                container.innerHTML = `
                    <div class="people-empty">
                        <div class="people-empty-icon">ðŸ”’</div>
                        <p>Connect to GitHub to see team members</p>
                    </div>
                `;
                return;
            }

            try {
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/collaborators`,
                    {
                        headers: {
                            'Authorization': `token ${token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }

                const collaborators = await response.json();
                collaboratorsLoaded = true;

                if (collaborators.length === 0) {
                    container.innerHTML = `
                        <div class="people-empty">
                            <div class="people-empty-icon">ðŸ‘¤</div>
                            <p>No collaborators found</p>
                        </div>
                    `;
                    return;
                }

                // Count by role
                const roleCounts = { admin: 0, maintain: 0, write: 0, triage: 0, read: 0 };
                collaborators.forEach(c => {
                    const role = c.role_name?.toLowerCase() || 'read';
                    if (roleCounts[role] !== undefined) roleCounts[role]++;
                });

                // Render stats
                statsContainer.innerHTML = `
                    <div class="people-stat"><strong>${collaborators.length}</strong> members</div>
                    ${roleCounts.admin > 0 ? `<div class="people-stat"><strong>${roleCounts.admin}</strong> admins</div>` : ''}
                `;

                // Render collaborator cards
                const cardsHtml = collaborators.map(c => {
                    const role = c.role_name?.toLowerCase() || 'read';
                    const roleLabel = role.charAt(0).toUpperCase() + role.slice(1);
                    const roleIcon = {
                        admin: 'ðŸ‘‘',
                        maintain: 'ðŸ”§',
                        write: 'âœï¸',
                        triage: 'ðŸ“‹',
                        read: 'ðŸ‘ï¸'
                    }[role] || 'ðŸ‘¤';

                    return `
                        <div class="collaborator-card">
                            <img class="collaborator-avatar" src="${c.avatar_url}" alt="${c.login}" loading="lazy">
                            <div class="collaborator-info">
                                <div class="collaborator-name">${c.login}</div>
                                <div class="collaborator-username">
                                    <a href="${c.html_url}" target="_blank" rel="noopener">@${c.login}</a>
                                </div>
                                <span class="collaborator-role role-${role}">${roleIcon} ${roleLabel}</span>
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = `<div class="collaborators-grid">${cardsHtml}</div>`;

            } catch (error) {
                console.error('Failed to load collaborators:', error);
                container.innerHTML = `
                    <div class="people-empty">
                        <div class="people-empty-icon">âš ï¸</div>
                        <p>Failed to load collaborators</p>
                        <p style="font-size: 0.875rem; margin-top: 0.5rem;">${error.message}</p>
                    </div>
                `;
            }
        }

        // Extend switchView to load collaborators when People tab is selected
        const originalSwitchView = switchView;
        switchView = function(viewName) {
            originalSwitchView(viewName);
            if (viewName === 'people') {
                loadCollaborators();
            }
        };

        // === GLOBAL ERROR HANDLER ===
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
            showToast('error', 'An error occurred. Check console for details.');
            // Reset loading states to prevent UI freeze
            STATE.isLoading = false;
            STATE.isSaving = false;
            document.querySelectorAll('.column-tasks').forEach(col => {
                col.style.opacity = '1';
            });
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
            showToast('error', 'Operation failed: ' + (e.reason?.message || 'Unknown error'));
            // Reset loading states
            STATE.isLoading = false;
            STATE.isSaving = false;
            document.querySelectorAll('.column-tasks').forEach(col => {
                col.style.opacity = '1';
            });
        });

        // === INIT ===
        document.addEventListener('DOMContentLoaded', async () => {
            // Restore activity sidebar state
            if (localStorage.getItem('activity-collapsed') === 'true') {
                const sidebar = document.getElementById('activity-sidebar');
                const icon = document.getElementById('activity-toggle-icon');
                const reopen = document.getElementById('activity-reopen');
                if (sidebar) sidebar.classList.add('collapsed');
                if (icon) icon.textContent = 'â˜°';
                if (reopen) reopen.style.display = 'flex';
            }
            // Auth is now handled by checkAuth() in the login script below
        });

        // Pause polling when tab not visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && STATE.token) {
                pollForUpdates();
            }
        });

        // Auto-refresh crons data every 5 minutes for live status updates
        let cronRefreshInterval = null;
        let cronRenderInterval = null;
        
        function startCronAutoRefresh() {
            if (cronRefreshInterval) clearInterval(cronRefreshInterval);
            if (cronRenderInterval) clearInterval(cronRenderInterval);
            
            // Re-render crons every 30 seconds to update running status
            cronRenderInterval = setInterval(() => {
                if (!document.hidden && STATE.crons && STATE.crons.length > 0) {
                    renderCrons();
                }
            }, 30 * 1000); // 30 seconds
            
            // Fetch fresh data from GitHub every 5 minutes
            cronRefreshInterval = setInterval(async () => {
                if (!document.hidden && STATE.token) {
                    try {
                        await loadCronsFromGitHub();
                        renderCrons();
                        console.log('ðŸ”„ Auto-refreshed cron data from GitHub');
                    } catch (e) {
                        console.warn('Auto-refresh crons failed:', e);
                    }
                }
            }, 5 * 60 * 1000); // 5 minutes
        }
        
        // Start auto-refresh after page loads
        setTimeout(startCronAutoRefresh, 10000); // Start 10s after load

        // === VERSION CHECK FUNCTIONS ===
        async function checkForUpdates() {
            try {
                // Add cache-busting to force fresh fetch
                const response = await fetch(`${VERSION_FILE}?t=${Date.now()}`, {
                    cache: 'no-store'
                });
                
                if (!response.ok) return;
                
                const versionData = await response.json();
                
                // First load - store current version
                if (currentVersion === null) {
                    currentVersion = versionData.buildHash;
                    console.log('[Version] Current build:', currentVersion);
                    return;
                }
                
                // Check if version changed
                if (versionData.buildHash !== currentVersion) {
                    console.log('[Version] New version detected:', versionData.buildHash);
                    showVersionBanner();
                }
            } catch (error) {
                console.log('[Version] Check failed:', error.message);
            }
        }

        function showVersionBanner() {
            const banner = document.getElementById('version-banner');
            if (banner) {
                banner.classList.add('visible');
            }
        }

        function dismissVersionBanner() {
            const banner = document.getElementById('version-banner');
            if (banner) {
                banner.classList.remove('visible');
            }
            // Stop checking for this session (user dismissed)
            if (versionCheckInterval) {
                clearInterval(versionCheckInterval);
                versionCheckInterval = null;
            }
        }

        function reloadPage() {
            // Force hard reload to get new version
            window.location.reload(true);
        }

        function startVersionCheck() {
            // Initial check
            checkForUpdates();
            
            // Periodic check
            versionCheckInterval = setInterval(checkForUpdates, VERSION_CHECK_INTERVAL);
            
            // Also check when tab becomes visible again
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    checkForUpdates();
                }
            });
        }

        // Start version check after page loads
        setTimeout(startVersionCheck, 5000);

        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (STATE.hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    </script>

    </div><!-- End Dashboard -->

    <script>
        // === LOGIN/AUTH GATE ===
        async function checkAuth() {
            // Check both old and new token keys, migrate if needed
            let token = localStorage.getItem('gh_token');
            if (!token) {
                const oldToken = localStorage.getItem('github_token');
                if (oldToken) {
                    // Migrate old token to new key
                    localStorage.setItem('gh_token', oldToken);
                    localStorage.removeItem('github_token');
                    localStorage.removeItem('github_user'); // Clean up old user data
                    token = oldToken;
                    console.log('Migrated token from github_token to gh_token');
                }
            }

            if (!token) {
                showLoginScreen();
                return;
            }

            // Validate token
            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: { 
                        'Authorization': `token ${token}`,
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (response.ok) {
                    const user = await response.json();
                    STATE.token = token;
                    STATE.user = user;
                    showDashboard();
                    await loadTasksFromGitHub();
                    await loadCronsFromGitHub(); // Load data after auth
                } else {
                    localStorage.removeItem('gh_token');
                    showLoginScreen();
                }
            } catch (e) {
                console.error('Auth check failed:', e);
                showLoginScreen();
            }
        }

        function showLoginScreen() {
            document.getElementById('login-screen').style.display = 'flex';
            document.getElementById('dashboard').style.display = 'none';
        }

        function showDashboard() {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';

            // Update UI with user info
            if (STATE.user) {
                document.getElementById('btn-connect').style.display = 'none';
                document.getElementById('user-profile').style.display = 'flex';
                document.getElementById('user-avatar').src = STATE.user.avatar_url;
                document.getElementById('user-name').textContent = STATE.user.login;
            }
        }

        async function handleLogin() {
            const tokenInput = document.getElementById('login-token-input');
            const token = tokenInput.value.trim();
            const errorDiv = document.getElementById('login-error');
            const loadingDiv = document.getElementById('login-loading');
            const btn = document.getElementById('login-btn');

            if (!token) {
                errorDiv.textContent = 'Please enter a token';
                errorDiv.style.display = 'block';
                return;
            }

            // Show loading
            errorDiv.style.display = 'none';
            loadingDiv.style.display = 'flex';
            btn.disabled = true;

            try {
                const response = await fetch('https://api.github.com.com/user', {
                    headers: { 
                        'Authorization': `token ${token}`,
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (response.ok) {
                    const user = await response.json();
                    localStorage.setItem('gh_token', token);
                    STATE.token = token;
                    STATE.user = user;
                    showDashboard();
                    await loadTasksFromGitHub();
                    await loadCronsFromGitHub();
                } else {
                    errorDiv.textContent = 'Invalid token. Please check and try again.';
                    errorDiv.style.display = 'block';
                }
            } catch (e) {
                errorDiv.textContent = 'Connection error. Please try again.';
                errorDiv.style.display = 'block';
            } finally {
                loadingDiv.style.display = 'none';
                btn.disabled = false;
            }
        }

        // Handle Enter key on login input
        document.getElementById('login-token-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') handleLogin();
        });

        // Check auth on page load
        checkAuth();
    </script>
</body>
</html>
<!-- test Wed Jan 28 19:46:49 CET 2026 -->
<!-- webhook test 19:54:54 -->
<!-- test 19:55:37 -->
<!-- final test 19:56:16 -->
<!-- ctx debug 19:56:50 -->
<!-- real push test 20:18:59 -->
<!-- FINAL TEST 20:20:41 -->